<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>立码定天下</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-22T09:55:24.316Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Lanht</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mach-O文件分析</title>
    <link href="http://yoursite.com/2020/05/22/Mach-O%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/05/22/Mach-O%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/</id>
    <published>2020-05-22T06:14:46.000Z</published>
    <updated>2020-05-22T09:55:24.316Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mach-O文件"><a href="#Mach-O文件" class="headerlink" title="Mach-O文件"></a>Mach-O文件</h3><p><code>Mach-O</code> 其实是 <code>Mach Object</code> 文件格式的缩写，是 <code>mac</code> 以及 <code>iOS</code> 上可执行文件的格式， 类似于 <code>windows</code> 上的 <code>PE</code> 格式 ( Portable Executable ) , <code>linux</code> 上的 <code>elf</code> 格式 ( Executable and Linking Format )  .</p><p>它是一种用于可执行文件、目标代码、动态库的文件格式。作为 <code>a.out</code> 格式的替代，<code>Mach-O</code> 提供了更强的扩展性。</p><p>但是除了可执行文件外 , 其实还有一些文件也是使用的 <code>Mach-O</code> 的文件格式 .</p><p>属于 <code>Mach-O</code> 格式的常见文件</p><blockquote><ul><li>目标文件 .o</li><li>库文件<ul><li>.a</li><li>.dylib</li><li>Framework</li></ul></li><li>可执行文件</li><li>dyld ( 动态链接器 )</li><li>.dsym ( 符号表 )</li></ul></blockquote><p><code>Mach-O</code> 并非一定是可执行文件 , 它是一种文件格式 , 分为 <code>Mach-O Object</code> 目标文件 、 <code>Mach-O ececutable</code> 可执行文件、 <code>Mach-O dynamically</code> 动态库文件、 <code>Mach-O dynamic linker</code> 动态链接器文件、 <code>Mach-O dSYM companion</code> 符号表文件 , 等等 .</p><h3 id="Mach-O文件结构"><a href="#Mach-O文件结构" class="headerlink" title="Mach-O文件结构"></a>Mach-O文件结构</h3><p>具体可以分为几个部分</p><p>文件头 mach64 Header<br>加载命令 Load Commands<br>文本段 __TEXT<br>数据段 __Data<br>动态库加载信息 Dynamic Loader Info<br>入口函数 Function Starts<br>符号表 Symbol Table<br>动态库符号表 Dynamic Symbol Table<br>字符串表 String Table<br><img src="1.jpg" alt=""></p><p><img src="2.jpg" alt=""></p><h3 id="Load-Commands-加载命令"><a href="#Load-Commands-加载命令" class="headerlink" title="Load Commands - 加载命令"></a>Load Commands - 加载命令</h3><p>Mach-O文件包含非常详细的加载指令，这些指令非常清晰地指示加载器如何设置并且加载二进制数据。Load Commands紧紧跟着二进制文件头。</p><p><img src="3.png" alt=""></p><h3 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h3><p>MachO 文件结构详解：<a href="https://juejin.im/post/5c67e7efe51d45164c75993b#heading-5" target="_blank" rel="noopener">https://juejin.im/post/5c67e7efe51d45164c75993b#heading-5</a></p><p>Mach-O文件格式和程序从加载到执行过程：<a href="https://blog.csdn.net/bjtufang/article/details/50628310" target="_blank" rel="noopener">https://blog.csdn.net/bjtufang/article/details/50628310</a></p><p>趣探 Mach-O：加载过程：<a href="https://juejin.im/post/5a0c5c3451882554bd509a46#heading-4" target="_blank" rel="noopener">https://juejin.im/post/5a0c5c3451882554bd509a46#heading-4</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Mach-O文件&quot;&gt;&lt;a href=&quot;#Mach-O文件&quot; class=&quot;headerlink&quot; title=&quot;Mach-O文件&quot;&gt;&lt;/a&gt;Mach-O文件&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Mach-O&lt;/code&gt; 其实是 &lt;code&gt;Mach Object&lt;/cod
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>NSURLSession</title>
    <link href="http://yoursite.com/2020/05/14/NSURLSession/"/>
    <id>http://yoursite.com/2020/05/14/NSURLSession/</id>
    <published>2020-05-14T03:27:49.000Z</published>
    <updated>2020-05-20T06:44:41.081Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>NSURLSession在2013年随着iOS7的发布一起面世，苹果对它的定位是作为NSURLConnection的替代者，然后逐步将NSURLConnection退出历史舞台。现在使用最广泛的第三方网络框架：AFNetworking、SDWebImage等等都使用了NSURLSession。</p><p>在WWDC 2013中，Apple的团队对NSURLConnection进行了重构，并推出了NSURLSession作为替代。NSURLSession将NSURLConnection替换为<em>NSURLSession<em>和</em>NSURLSessionConfiguration<em>，以及3个NSURLSessionTask的子类：</em>NSURLSessionDataTask</em>, <em>NSURLSessionUploadTask</em>, 和<em>NSURLSessionDownloadTask</em>。</p><p><img src="1.jpg" alt=""></p><p>NSURLSessionTask及三个子类继承关系：</p><p><img src="2.jpg" alt=""></p><p><strong>NSURLSessionTask及其子类</strong></p><p><strong><code>NSURLSessionTask</code>本身是一个抽象类，在使用的时候，通常是根据具体的需求使用它的几个子类</strong> </p><p><strong><code>NSURLSessionDataTask</code>可以用来发送常见的Get，Post请求，既可以用来上传也可以用来下载</strong></p><p> <strong><code>NSURLSessionDownloadTask</code>可以用来发送下载请求，专门用来下载数据</strong></p><p> <strong><code>NSURLSessionUploadTask</code>可以用来发送上传请求，专门用来上传数据</strong></p><h3 id="二、NSURLSession的使用"><a href="#二、NSURLSession的使用" class="headerlink" title="二、NSURLSession的使用"></a>二、NSURLSession的使用</h3><p>NSURLSession 本身是不会进行请求的，而是通过创建 task 的形式进行网络请求（resume() 方法的调用），同一个 NSURLSession 可以创建多个 task，并且这些 task 之间的 cache 和 cookie 是共享的。NSURLSession的使用有如下几步：</p><ul><li>第一步：创建NSURLSession对象</li><li>第二步：使用NSURLSession对象创建Task</li><li>第三步：启动任务</li></ul><h4 id="创建NSURLSession对象"><a href="#创建NSURLSession对象" class="headerlink" title="创建NSURLSession对象"></a>创建NSURLSession对象</h4><p>NSURLSession对象的创建有如下三种方法：</p><p>（1）直接创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSURLSession *session &#x3D; [NSURLSession sharedSession];</span><br></pre></td></tr></table></figure><p>（2）配置后创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSURLSession sessionWithConfiguration:defaultSessionConfiguration];</span><br></pre></td></tr></table></figure><p>（3）设置加代理获得</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用代理方法需要设置代理,但是session的delegate属性是只读的,要想设置代理只能通过这种方式创建session</span><br><span class="line">NSURLSession *session &#x3D; [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]</span><br><span class="line">    delegate:self</span><br><span class="line">    delegateQueue:[[NSOperationQueue alloc] init]];</span><br></pre></td></tr></table></figure><p>关于NSURLSession的配置有三种类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;默认的配置会将缓存存储在磁盘上</span><br><span class="line">+ (NSURLSessionConfiguration *)defaultSessionConfiguration;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;瞬时会话模式不会创建持久性存储的缓存</span><br><span class="line">+ (NSURLSessionConfiguration *)ephemeralSessionConfiguration;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;后台会话模式允许程序在后台进行上传下载工作</span><br><span class="line">+ (NSURLSessionConfiguration *)backgroundSessionConfigurationWithIdentifier:(NSString *)identifier</span><br></pre></td></tr></table></figure><h4 id="使用NSURLSession对象创建Task"><a href="#使用NSURLSession对象创建Task" class="headerlink" title="使用NSURLSession对象创建Task"></a>使用NSURLSession对象创建Task</h4><p>NSURLSessionTask的创建要根据具体需要创建相应类型的Task。</p><p>（1）NSURLSessionDataTask</p><p>通过request对象或url创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request;</span><br><span class="line"></span><br><span class="line">- (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url;</span><br></pre></td></tr></table></figure><p>通过request对象或url创建，同时指定任务完成后通过completionHandler指定回调的代码块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler;    </span><br><span class="line"></span><br><span class="line">- (NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler;</span><br></pre></td></tr></table></figure><p>（2）NSURLSessionUploadTask</p><p>通过request创建，在上传时指定文件源或数据源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL;  </span><br><span class="line">   </span><br><span class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData;  </span><br><span class="line">  </span><br><span class="line">- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request;</span><br></pre></td></tr></table></figure><p>通过completionHandler指定任务完成后的回调代码块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler;    </span><br><span class="line"></span><br><span class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler;</span><br></pre></td></tr></table></figure><p>（3）NSURLSessionDownloadTask</p><p>下载任务支持断点续传，第三种方式是通过之前已经下载的数据来创建下载任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request;    </span><br><span class="line">    </span><br><span class="line">- (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url;    </span><br><span class="line">  </span><br><span class="line">- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData;</span><br></pre></td></tr></table></figure><p>同样地可以通过completionHandler指定任务完成后的回调代码块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURL *location, NSURLResponse *response, NSError *error))completionHandler;    </span><br><span class="line"></span><br><span class="line">- (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSURL *location, NSURLResponse *response, NSError *error))completionHandler;    </span><br><span class="line"></span><br><span class="line">- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData completionHandler:(void (^)(NSURL *location, NSURLResponse *response, NSError *error))completionHandler;</span><br></pre></td></tr></table></figure><p>我们在使用三种 task 的任意一种的时候都可以指定相应的代理。NSURLSession 的代理对象结构如下：</p><p><img src="3.jpg" alt=""></p><p><em>NSURLSessionDelegate</em> – 作为所有代理的基类，定义了网络请求最基础的代理方法。</p><p><em>NSURLSessionTaskDelegate</em> – 定义了网络请求任务相关的代理方法。</p><p><em>NSURLSessionDownloadDelegate</em> – 用于下载任务相关的代理方法，比如下载进度等等。</p><p><em>NSURLSessionDataDelegate</em> – 用于普通数据任务和上传任务。</p><h4 id="启动任务"><a href="#启动任务" class="headerlink" title="启动任务"></a>启动任务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 启动任务</span><br><span class="line">[task resume];</span><br></pre></td></tr></table></figure><h3 id="三、GET请求与POST请求"><a href="#三、GET请求与POST请求" class="headerlink" title="三、GET请求与POST请求"></a>三、GET请求与POST请求</h3><p>1、GET 请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1、创建NSURLSession对象</span><br><span class="line">NSURLSession *session &#x3D; [NSURLSession sharedSession];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2、利用NSURLSession创建任务(task)</span><br><span class="line">NSURL *url &#x3D; [NSURL URLWithString:@&quot;http:&#x2F;&#x2F;www.xxx.com&#x2F;login?username&#x3D;myName&amp;pwd&#x3D;myPsd&quot;];</span><br><span class="line"></span><br><span class="line">NSURLSessionDataTask *task &#x3D; [session dataTaskWithURL:url completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@&quot;,[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]);</span><br><span class="line">    &#x2F;&#x2F;打印解析后的json数据</span><br><span class="line">    &#x2F;&#x2F;NSLog(@&quot;%@&quot;, [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil]);</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3、执行任务</span><br><span class="line">[task resume];</span><br></pre></td></tr></table></figure><p>2、POST请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1、创建NSURLSession对象</span><br><span class="line">NSURLSession *session &#x3D; [NSURLSession sharedSession];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2、利用NSURLSession创建任务(task)</span><br><span class="line">NSURL *url &#x3D; [NSURL URLWithString:@&quot;http:&#x2F;&#x2F;www.xxx.com&#x2F;login&quot;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建请求对象里面包含请求体</span><br><span class="line">NSMutableURLRequest *request &#x3D; [NSMutableURLRequest requestWithURL:url];</span><br><span class="line">request.HTTPMethod &#x3D; @&quot;POST&quot;;</span><br><span class="line">request.HTTPBody &#x3D; [@&quot;username&#x3D;myName&amp;pwd&#x3D;myPsd&quot; dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">NSURLSessionDataTask *task &#x3D; [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">      </span><br><span class="line">    NSLog(@&quot;%@&quot;,[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]);</span><br><span class="line">    &#x2F;&#x2F;打印解析后的json数据</span><br><span class="line">    &#x2F;&#x2F;NSLog(@&quot;%@&quot;, [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil]);</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3、执行任务</span><br><span class="line"> [task resume];</span><br></pre></td></tr></table></figure><h3 id="四、文件的上传"><a href="#四、文件的上传" class="headerlink" title="四、文件的上传"></a>四、文件的上传</h3><p>我们可以使用NSURLSessionUploadTask进行文件的上传</p><p><strong>创建方法</strong>（基于 <code>NSURLSession</code> 对象）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用 NSURLRequest 对象创建，上传时指定文件源</span><br><span class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL;  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 NSURLRequest 对象创建，上传时指定数据源   </span><br><span class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData;  </span><br><span class="line">  </span><br><span class="line">- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request;</span><br></pre></td></tr></table></figure><p><strong>CompletionHandler</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromFile:(NSURL *)fileURL completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler;    </span><br><span class="line"></span><br><span class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(NSData *)bodyData completionHandler:(void (^)(NSData *data, NSURLResponse *response, NSError *error))completionHandler;</span><br></pre></td></tr></table></figure><p><strong>关于分片上传和断点续传上传</strong></p><p>可以参考阿里云AliyunOSSiOS源码及文档</p><p>文档地址：<a href="https://help.aliyun.com/document_detail/31850.html?spm=a2c4g.11186623.6.610.62d72201Fvv00V" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/31850.html?spm=a2c4g.11186623.6.610.62d72201Fvv00V</a></p><h3 id="五、文件的下载"><a href="#五、文件的下载" class="headerlink" title="五、文件的下载"></a>五、文件的下载</h3><p>我们可以使用NSURLSessionDownloadTask实现文件的下载。</p><p><code>NSURLSessionDownloadTask</code> 主要用于 <strong>文件下载</strong>，它针对大文件的网络请求做了更多的处理，如：下载进度、断点续传等。</p><p><strong>创建方法</strong>（基于 <code>NSURLSession</code> 对象）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用 NSURLRequest 对象创建</span><br><span class="line">- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request;    </span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 使用 NSURL 对象创建</span><br><span class="line">- (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url;    </span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 使用之前已经下载的数据来创建</span><br><span class="line">- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData;</span><br></pre></td></tr></table></figure><p><strong>CompletionHandler</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURL *location, NSURLResponse *response, NSError *error))completionHandler;    </span><br><span class="line"></span><br><span class="line">- (NSURLSessionDownloadTask *)downloadTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSURL *location, NSURLResponse *response, NSError *error))completionHandler;    </span><br><span class="line"></span><br><span class="line">- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData completionHandler:(void (^)(NSURL *location, NSURLResponse *response, NSError *error))completionHandler;</span><br></pre></td></tr></table></figure><p><strong>关于断点续传下载</strong></p><p>设计思路是用请求的Range</p><p>iOS断点续传：<a href="https://cloud.tencent.com/developer/article/1423899" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1423899</a></p><p>AFNetworking 实现断点续传：<a href="http://www.yangjie.hu/2018/05/15/breakpoint-resume-in-iOS/" target="_blank" rel="noopener">http://www.yangjie.hu/2018/05/15/breakpoint-resume-in-iOS/</a></p><h3 id="六、补充"><a href="#六、补充" class="headerlink" title="六、补充"></a>六、补充</h3><p>iOS 利用AFNetworking实现大文件分片上传</p><p><a href="https://www.jianshu.com/p/7919c620967e" target="_blank" rel="noopener">https://www.jianshu.com/p/7919c620967e</a></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>NSURLSession：<a href="https://www.jianshu.com/p/e798c6fe26ea" target="_blank" rel="noopener">https://www.jianshu.com/p/e798c6fe26ea</a></p><p>iOS 网络(1)——NSURLSession: <a href="http://chuquan.me/2019/07/21/ios-network-nsurlsession/" target="_blank" rel="noopener">http://chuquan.me/2019/07/21/ios-network-nsurlsession/</a></p><p>iOS NSURLSession 详解：<a href="https://juejin.im/entry/58aacabcac502e006973ce03" target="_blank" rel="noopener">https://juejin.im/entry/58aacabcac502e006973ce03</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h3&gt;&lt;p&gt;NSURLSession在2013年随着iOS7的发布一起面世，苹果对它的定位是作为NSURLConnection的替代者，
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>AFNetworking使用分析</title>
    <link href="http://yoursite.com/2020/05/12/AFNetworking%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/05/12/AFNetworking%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/</id>
    <published>2020-05-12T06:45:03.000Z</published>
    <updated>2020-05-15T07:32:48.766Z</updated>
    
    <content type="html"><![CDATA[<p>基于3.x进行使用分析</p><h4 id="前景回顾"><a href="#前景回顾" class="headerlink" title="前景回顾"></a>前景回顾</h4><p>NSURLConnection（在iOS8.0后弃用）</p><p>NSURLSession</p><p>AF2.x是对NSURLConnection的封装</p><p>AF3.x是对NSURLSession的封装</p><p><strong>AF2.x为什么需要常驻线程？</strong></p><p>先来看看 NSURLConnection 发送请求时的线程情况，NSURLConnection 是被设计成异步发送的，调用了start方法后，NSURLConnection 会新建一些线程用底层的 CFSocket 去发送和接收请求，在发送和接收的一些事件发生后通知原来线程的Runloop去回调事件。</p><p><strong>AF3.x为什么不需要常驻线程？</strong></p><p>NSURLSession发起的请求，不再需要在当前线程进行代理方法的回调！可以指定回调的delegateQueue，这样我们就不用为了等待代理回调方法而苦苦保活线程了。</p><p><strong>为什么AF3.0中需要设置</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.operationQueue.maxConcurrentOperationCount = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>而AF2.0却不需要？</p><p>解答：功能不一样：AF3.0的operationQueue是用来接收NSURLSessionDelegate回调的，鉴于一些多线程数据访问的安全性考虑，设置了maxConcurrentOperationCount = 1来达到串行回调的效果。<br>而AF2.0的operationQueue是用来添加operation并进行并发请求的，所以不要设置为1。</p><h4 id="AF分为如下5个功能模块："><a href="#AF分为如下5个功能模块：" class="headerlink" title="AF分为如下5个功能模块："></a>AF分为如下5个功能模块：</h4><ul><li><p>网络通信模块(AFURLSessionManager、AFHTTPSessionManger)</p></li><li><p>网络状态监听模块(Reachability)</p></li><li><p>网络通信安全策略模块(Security)</p></li><li><p>网络通信信息序列化/反序列化模块(Serialization)</p></li><li><p>对于iOS UIKit库的扩展(UIKit)</p></li></ul><h5 id="网络通信模块"><a href="#网络通信模块" class="headerlink" title="网络通信模块"></a>网络通信模块</h5><p>其核心当然是网络通信模块AFURLSessionManager。大家都知道，AF3.x是基于NSURLSession来封装的。所以这个类围绕着NSURLSession做了一系列的封装。而其余的四个模块，均是为了配合网络通信或对已有UIKit的一个扩展工具包。</p><p>其中AFHTTPSessionManager是继承于AFURLSessionManager的，我们一般做网络请求都是用这个类，<strong>但是它本身是没有做实事的，只是做了一些简单的封装，把请求逻辑分发给父类AFURLSessionManager或者其它类去做。</strong></p><p>AFURLSessionManager初始化</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!configuration) &#123;</span><br><span class="line">        configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.sessionConfiguration = configuration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.operationQueue.maxConcurrentOperationCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span>.sessionConfiguration delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span>.operationQueue];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_OS_WATCH</span></span><br><span class="line">    <span class="keyword">self</span>.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.lock.name = AFURLSessionManagerLockName;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.session getTasksWithCompletionHandler:^(<span class="built_in">NSArray</span> *dataTasks, <span class="built_in">NSArray</span> *uploadTasks, <span class="built_in">NSArray</span> *downloadTasks) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionDataTask</span> *task <span class="keyword">in</span> dataTasks) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addDelegateForDataTask:task uploadProgress:<span class="literal">nil</span> downloadProgress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionUploadTask</span> *uploadTask <span class="keyword">in</span> uploadTasks) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addDelegateForUploadTask:uploadTask progress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionDownloadTask</span> *downloadTask <span class="keyword">in</span> downloadTasks) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addDelegateForDownloadTask:downloadTask progress:<span class="literal">nil</span> destination:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化方法中，需要完成初始化一些自己持有的实例：</p><ol><li>初始化<strong>会话配置</strong>（NSURLSessionConfiguration），默认为 <code>defaultSessionConfiguration</code></li><li>初始化会话（session），并设置会话的代理以及代理队列</li><li>初始化管理<strong>响应序列化</strong>（AFJSONResponseSerializer），<strong>安全认证</strong>（AFSecurityPolicy）以及<strong>监控网络状态</strong>（AFNetworkReachabilityManager）的实例</li><li>初始化保存 data task 的字典（mutableTaskDelegatesKeyedByTaskIdentifier）</li></ol><p>在获得了 <code>AFURLSessionManager</code> 的实例之后，我们可以通过以下方法创建 <code>NSURLSessionDataTask</code> 的实例：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                         fromFile:(<span class="built_in">NSURL</span> *)fileURL</span><br><span class="line">                                         progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">                                completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject, <span class="built_in">NSError</span>  * _Nullable error))completionHandler;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                             progress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                                          destination:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> * (^)(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response))destination</span><br><span class="line">                                    completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> * _Nullable filePath, <span class="built_in">NSError</span> * _Nullable error))completionHandler;</span><br></pre></td></tr></table></figure><p>我们将以 <code>- [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:]</code> 方法的实现为例，分析它是如何实例化并返回一个 <code>NSURLSessionTask</code> 的实例的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        dataTask = [<span class="keyword">self</span>.session dataTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>url_session_manager_create_task_safely</code> 的调用是因为苹果框架中的一个 bug <a href="https://github.com/AFNetworking/AFNetworking/issues/2093" target="_blank" rel="noopener">#2093</a>，如果有兴趣可以看一下，在这里就不说明了</p></blockquote><ol><li>调用 <code>- [NSURLSession dataTaskWithRequest:]</code> 方法传入 <code>NSURLRequest</code></li><li>调用 <code>- [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:]</code> 方法返回一个 <code>AFURLSessionManagerTaskDelegate</code> 对象</li><li>将 <code>completionHandler</code> <code>uploadProgressBlock</code> 和 <code>downloadProgressBlock</code> 传入该对象并在相应事件发生时进行回调</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> (<span class="keyword">void</span>)addDelegateForDataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">                uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</span><br><span class="line">    delegate.manager = <span class="keyword">self</span>;</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">    dataTask.taskDescription = <span class="keyword">self</span>.taskDescriptionForSessionTasks;</span><br><span class="line">    [<span class="keyword">self</span> setDelegate:delegate forTask:dataTask];</span><br><span class="line"></span><br><span class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中同时调用了另一个方法 <code>- [AFURLSessionManager setDelegate:forTask:]</code> 来设置代理：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">#<span class="number">1</span>: 检查参数, 略</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</span><br><span class="line">    [<span class="keyword">self</span> addNotificationObserverForTask:task];</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="网络状态监听模块"><a href="#网络状态监听模块" class="headerlink" title="网络状态监听模块"></a>网络状态监听模块</h5><p><code>AFNetworkReachabilityManager</code> 是对 <code>SystemConfiguration</code> 模块的封装，苹果的文档中也有一个类似的项目 <a href="https://developer.apple.com/library/ios/samplecode/reachability/" target="_blank" rel="noopener">Reachability</a> 这里对网络状态的监控跟苹果官方的实现几乎是完全相同的。</p><p><strong>AFNetworkReachabilityManager 的使用和实现</strong></p><p><code>AFNetworkReachabilityManager</code> 的使用还是非常简单的，只需要三个步骤，就基本可以完成对网络状态的监控。</p><ol><li><a href="">初始化 <code>AFNetworkReachabilityManager</code></a></li><li><a href="">调用 <code>startMonitoring</code> 方法开始对网络状态进行监控</a></li><li><a href="">设置 <code>networkReachabilityStatusBlock</code> 在每次网络状态改变时, 调用这个 block</a></li></ol><h5 id="网络通信安全策略模块"><a href="#网络通信安全策略模块" class="headerlink" title="网络通信安全策略模块"></a>网络通信安全策略模块</h5><p>用于HTTPS中的SSL校验规则设置，验证证书是否正确。</p><p>自 iOS9 发布之后，由于新特性 <a href="https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html" target="_blank" rel="noopener">App Transport Security</a> 的引入，在默认行为下是不能发送 HTTP 请求的。很多网站都在转用 HTTPS，而 <code>AFNetworking</code> 中的 <code>AFSecurityPolicy</code> 就是为了阻止中间人攻击，以及其它漏洞的工具。</p><p><code>AFSecurityPolicy</code> 主要作用就是验证 HTTPS 请求的证书是否有效，如果 app 中有一些敏感信息或者涉及交易信息，一定要使用 HTTPS 来保证交易或者用户信息的安全。</p><ul><li><p>AFSSLPinningMode</p><p>使用 <code>AFSecurityPolicy</code> 时，总共有三种验证服务器是否被信任的方式：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, AFSSLPinningMode) &#123;</span><br><span class="line">    AFSSLPinningModeNone,</span><br><span class="line">    AFSSLPinningModePublicKey,</span><br><span class="line">    AFSSLPinningModeCertificate,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>AFSSLPinningModeNone</code> 是默认的认证方式，只会在系统的信任的证书列表中对服务端返回的证书进行验证</li><li><code>AFSSLPinningModeCertificate</code> 需要客户端预先保存服务端的证书</li><li><code>AFSSLPinningModePublicKey</code> 也需要预先保存服务端发送的证书，但是这里只会验证证书中的公钥是否正确</li></ul></li><li><p>初始化以及设置</p><p>在使用 <code>AFSecurityPolicy</code> 验证服务端是否受到信任之前，要对其进行初始化，使用初始化方法时，主要目的是设置<strong>验证服务器是否受信任的方式</strong>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)policyWithPinningMode:(AFSSLPinningMode)pinningMode &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> policyWithPinningMode:pinningMode withPinnedCertificates:[<span class="keyword">self</span> defaultPinnedCertificates]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(<span class="built_in">NSSet</span> *)pinnedCertificates &#123;</span><br><span class="line">    AFSecurityPolicy *securityPolicy = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    securityPolicy.SSLPinningMode = pinningMode;</span><br><span class="line"></span><br><span class="line">    [securityPolicy setPinnedCertificates:pinnedCertificates];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> securityPolicy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里没有什么地方值得解释的。不过在调用 <code>pinnedCertificate</code> 的 setter 方法时，会从全部的证书中<strong>取出公钥</strong>保存到 <code>pinnedPublicKeys</code> 属性中。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setPinnedCertificates:(<span class="built_in">NSSet</span> *)pinnedCertificates &#123;</span><br><span class="line">    _pinnedCertificates = pinnedCertificates;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.pinnedCertificates) &#123;</span><br><span class="line">        <span class="built_in">NSMutableSet</span> *mutablePinnedPublicKeys = [<span class="built_in">NSMutableSet</span> setWithCapacity:[<span class="keyword">self</span>.pinnedCertificates count]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSData</span> *certificate <span class="keyword">in</span> <span class="keyword">self</span>.pinnedCertificates) &#123;</span><br><span class="line">            <span class="keyword">id</span> publicKey = AFPublicKeyForCertificate(certificate);</span><br><span class="line">            <span class="keyword">if</span> (!publicKey) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            [mutablePinnedPublicKeys addObject:publicKey];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.pinnedPublicKeys = [<span class="built_in">NSSet</span> setWithSet:mutablePinnedPublicKeys];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.pinnedPublicKeys = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里调用了 <code>AFPublicKeyForCertificate</code> 对证书进行操作，返回一个公钥。</p></li><li><p>操作 SecTrustRef</p><p>对 <code>serverTrust</code> 的操作的函数基本上都是 C 的 API，都定义在 <code>Security</code> 模块中，先来分析一下在上一节中 <code>AFPublicKeyForCertificate</code> 的实现</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> AFPublicKeyForCertificate(<span class="built_in">NSData</span> *certificate) &#123;</span><br><span class="line">  <span class="comment">//1.初始化一坨临时变量</span></span><br><span class="line">    <span class="keyword">id</span> allowedPublicKey = <span class="literal">nil</span>;</span><br><span class="line">    SecCertificateRef allowedCertificate;</span><br><span class="line">    SecCertificateRef allowedCertificates[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">CFArrayRef</span> tempCertificates = <span class="literal">nil</span>;</span><br><span class="line">    SecPolicyRef policy = <span class="literal">nil</span>;</span><br><span class="line">    SecTrustRef allowedTrust = <span class="literal">nil</span>;</span><br><span class="line">    SecTrustResultType result;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.使用 SecCertificateCreateWithData 通过 DER 表示的数据生成一个 SecCertificateRef，然后判断返回值是否为 NULL</span></span><br><span class="line">  <span class="comment">//这里使用了一个非常神奇的宏 __Require_Quiet，它会判断 allowedCertificate != NULL 是否成立，如果 allowedCertificate 为空就会跳到 _out 标签处继续执行</span></span><br><span class="line">    allowedCertificate = SecCertificateCreateWithData(<span class="literal">NULL</span>, (__bridge <span class="built_in">CFDataRef</span>)certificate);</span><br><span class="line">    __Require_Quiet(allowedCertificate != <span class="literal">NULL</span>, _<span class="keyword">out</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3.通过上面的 allowedCertificate 创建一个 CFArray</span></span><br><span class="line">    allowedCertificates[<span class="number">0</span>] = allowedCertificate;</span><br><span class="line">    tempCertificates = <span class="built_in">CFArrayCreate</span>(<span class="literal">NULL</span>, (<span class="keyword">const</span> <span class="keyword">void</span> **)allowedCertificates, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4.创建一个默认的符合 X509 标准的 SecPolicyRef，通过默认的 SecPolicyRef 和证书创建一个 SecTrustRef 用于信任评估，对该对象进行信任评估，确认生成的 SecTrustRef 是值得信任的。</span></span><br><span class="line">    policy = SecPolicyCreateBasicX509();</span><br><span class="line">    __Require_noErr_Quiet(SecTrustCreateWithCertificates(tempCertificates, policy, &amp;allowedTrust), _<span class="keyword">out</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这里使用的 __Require_noErr_Quiet 和上面的宏差不多，只是会根据返回值判断是否存在错误</span></span><br><span class="line">    __Require_noErr_Quiet(SecTrustEvaluate(allowedTrust, &amp;result), _<span class="keyword">out</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//5.获取公钥</span></span><br><span class="line">    allowedPublicKey = (__bridge_transfer <span class="keyword">id</span>)SecTrustCopyPublicKey(allowedTrust);</span><br><span class="line"></span><br><span class="line">_<span class="keyword">out</span>:</span><br><span class="line">    <span class="keyword">if</span> (allowedTrust) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(allowedTrust);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (policy) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(policy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tempCertificates) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(tempCertificates);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (allowedCertificate) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(allowedCertificate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> allowedPublicKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对它的操作还有 <code>AFCertificateTrustChainForServerTrust</code> 和 <code>AFPublicKeyTrustChainForServerTrust</code> 但是它们几乎调用了相同的 API。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * AFCertificateTrustChainForServerTrust(SecTrustRef serverTrust) &#123;</span><br><span class="line">    <span class="built_in">CFIndex</span> certificateCount = SecTrustGetCertificateCount(serverTrust);</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *trustChain = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:(<span class="built_in">NSUInteger</span>)certificateCount];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">CFIndex</span> i = <span class="number">0</span>; i &lt; certificateCount; i++) &#123;</span><br><span class="line">        SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i);</span><br><span class="line">        [trustChain addObject:(__bridge_transfer <span class="built_in">NSData</span> *)SecCertificateCopyData(certificate)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:trustChain];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>验证服务端是否受信</p><p>验证服务端是否守信是通过 <code>- [AFSecurityPolicy evaluateServerTrust:forDomain:]</code> 方法进行的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)evaluateServerTrust:(SecTrustRef)serverTrust</span><br><span class="line">                  forDomain:(<span class="built_in">NSString</span> *)domain</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">#<span class="number">1</span>: 不能隐式地信任自己签发的证书</span><br><span class="line"></span><br><span class="line">#<span class="number">2</span>: 设置 policy</span><br><span class="line"></span><br><span class="line">#<span class="number">3</span>: 验证证书是否有效</span><br><span class="line"></span><br><span class="line">#<span class="number">4</span>: 根据 SSLPinningMode 对服务端进行验证</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>不能隐式地信任自己签发的证书</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (domain &amp;&amp; self.allowInvalidCertificates &amp;&amp; self.validatesDomainName &amp;&amp; (self.SSLPinningMode &#x3D;&#x3D; AFSSLPinningModeNone || [self.pinnedCertificates count] &#x3D;&#x3D; 0)) &#123;</span><br><span class="line">    NSLog(@&quot;In order to validate a domain name for self signed certificates, you MUST use pinning.&quot;);</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以如果没有提供证书或者不验证证书，并且还设置 <code>allowInvalidCertificates</code> 为<strong>真</strong>，满足上面的所有条件，说明这次的验证是不安全的，会直接返回 <code>NO</code></p></li><li><p>设置 policy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *policies &#x3D; [NSMutableArray array];</span><br><span class="line"> if (self.validatesDomainName) &#123;</span><br><span class="line">     [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)];</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">     [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果要验证域名的话，就以域名为参数创建一个 <code>SecPolicyRef</code>，否则会创建一个符合 X509 标准的默认 <code>SecPolicyRef</code> 对象</p></li><li><p>验证证书的有效性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (self.SSLPinningMode &#x3D;&#x3D; AFSSLPinningModeNone) &#123;</span><br><span class="line">     return self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);</span><br><span class="line"> &#125; else if (!AFServerTrustIsValid(serverTrust) &amp;&amp; !self.allowInvalidCertificates) &#123;</span><br><span class="line">     return NO;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>如果<strong>只根据信任列表中的证书</strong>进行验证，即 <code>self.SSLPinningMode == AFSSLPinningModeNone</code>。如果允许无效的证书的就会直接返回 <code>YES</code>。不允许就会对服务端信任进行验证。</li><li>如果服务器信任无效，并且不允许无效证书，就会返回 <code>NO</code></li></ul></li><li><p>根据 <code>SSLPinningMode</code> 对服务器信任进行验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">switch (self.SSLPinningMode) &#123;</span><br><span class="line">     case AFSSLPinningModeNone:</span><br><span class="line">     default:</span><br><span class="line">         return NO;</span><br><span class="line">     case AFSSLPinningModeCertificate: &#123;</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line">     case AFSSLPinningModePublicKey: &#123;</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><code>AFSSLPinningModeNone</code> 直接返回 <code>NO</code></li><li><code>AFSSLPinningModeCertificate</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *pinnedCertificates &#x3D; [NSMutableArray array];</span><br><span class="line">  for (NSData *certificateData in self.pinnedCertificates) &#123;</span><br><span class="line">      [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)];</span><br><span class="line">  &#125;</span><br><span class="line">  SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates);</span><br><span class="line"></span><br><span class="line">  if (!AFServerTrustIsValid(serverTrust)) &#123;</span><br><span class="line">      return NO;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it&#39;s the Root CA)</span><br><span class="line">  NSArray *serverCertificates &#x3D; AFCertificateTrustChainForServerTrust(serverTrust);</span><br><span class="line"></span><br><span class="line">  for (NSData *trustChainCertificate in [serverCertificates reverseObjectEnumerator]) &#123;</span><br><span class="line">      if ([self.pinnedCertificates containsObject:trustChainCertificate]) &#123;</span><br><span class="line">          return YES;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return NO;</span><br></pre></td></tr></table></figure><ol><li>从 <code>self.pinnedCertificates</code> 中获取 DER 表示的数据</li><li>使用 <code>SecTrustSetAnchorCertificates</code> 为服务器信任设置证书</li><li>判断服务器信任的有效性</li><li>使用 <code>AFCertificateTrustChainForServerTrust</code> 获取服务器信任中的全部 DER 表示的证书</li><li>如果 <code>pinnedCertificates</code> 中有相同的证书，就会返回 <code>YES</code></li></ol><ul><li>AFSSLPinningModePublicKey</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSUInteger trustedPublicKeyCount &#x3D; 0;</span><br><span class="line"> NSArray *publicKeys &#x3D; AFPublicKeyTrustChainForServerTrust(serverTrust);</span><br><span class="line">     </span><br><span class="line"> for (id trustChainPublicKey in publicKeys) &#123;</span><br><span class="line">     for (id pinnedPublicKey in self.pinnedPublicKeys) &#123;</span><br><span class="line">         if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</span><br><span class="line">             trustedPublicKeyCount +&#x3D; 1;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return trustedPublicKeyCount &gt; 0;</span><br></pre></td></tr></table></figure><p>这部分的实现和上面的差不多，区别有两点</p><ol><li>会从服务器信任中获取公钥</li><li><code>pinnedPublicKeys</code> 中的公钥与服务器信任中的公钥相同的数量大于 0，就会返回真</li></ol></li></ol></li><li><p>与 AFURLSessionManager 协作</p><p>在代理协议 <code>- URLSession:didReceiveChallenge:completionHandler:</code> 或者 <code>- URLSession:task:didReceiveChallenge:completionHandler:</code> 代理方法被调用时会运行这段代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">        disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>;</span><br><span class="line">        credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        disposition = <span class="built_in">NSURLSessionAuthChallengeRejectProtectionSpace</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NSURLAuthenticationChallenge</code> 表示一个认证的挑战，提供了关于这次认证的全部信息。它有一个非常重要的属性 <code>protectionSpace</code>，这里保存了需要认证的保护空间, 每一个 <code>NSURLProtectionSpace</code> 对象都保存了主机地址，端口和认证方法等重要信息。</p><p>在上面的方法中，如果保护空间中的认证方法为 <code>NSURLAuthenticationMethodServerTrust</code>，那么就会使用在上一小节中提到的方法 <code>- [AFSecurityPolicy evaluateServerTrust:forDomain:]</code> 对保护空间中的 <code>serverTrust</code> 以及域名 <code>host</code> 进行认证</p><p>根据认证的结果，会在 <code>completionHandler</code> 中传入不同的 <code>disposition</code> 和 <code>credential</code> 参数。</p></li></ul><h5 id="网络通信信息序列化-反序列化模块"><a href="#网络通信信息序列化-反序列化模块" class="headerlink" title="网络通信信息序列化/反序列化模块"></a>网络通信信息序列化/反序列化模块</h5><p>设置<strong>网络请求</strong>的序列化对象：满足<strong>AFURLRequestSerialization</strong>协议的AFHTTPRequestSerializer对象（当然还有别的子类），配置请求的<strong>cookies</strong>，<strong>timeout</strong>，字符串编码方式（<strong>stringEncoding</strong>），http的<strong>headertype</strong>，<strong>user-agent</strong>等。</p><p>设置<strong>返回数据</strong>的序列化对象：满足<strong>AFURLResponseSerialization</strong>协议的<strong>AFHTTPResponseSerializer</strong>对象（JSON、XML等其他对象默认配置了statuscode和contenttypes），配置返回数据的<strong>acceptableStatusCodes</strong>和<strong>acceptableContentTypes</strong>，检查返回数据<strong>是否合法</strong>并进行转化。</p><p>注：AFJSONResponseSerializer序列化对象的底层是使用Foundation中<strong>内置的NSJSONSerialization对象</strong>实现的。</p><h5 id="对于iOS-UIKit库的扩展"><a href="#对于iOS-UIKit库的扩展" class="headerlink" title="对于iOS UIKit库的扩展"></a>对于iOS UIKit库的扩展</h5><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p>AFNetworking 概述系列文章：<a href="https://draveness.me/afnetworking1/" target="_blank" rel="noopener">https://draveness.me/afnetworking1/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基于3.x进行使用分析&lt;/p&gt;
&lt;h4 id=&quot;前景回顾&quot;&gt;&lt;a href=&quot;#前景回顾&quot; class=&quot;headerlink&quot; title=&quot;前景回顾&quot;&gt;&lt;/a&gt;前景回顾&lt;/h4&gt;&lt;p&gt;NSURLConnection（在iOS8.0后弃用）&lt;/p&gt;
&lt;p&gt;NSURLSes
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>图像绘制原理</title>
    <link href="http://yoursite.com/2020/05/12/%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/05/12/%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86/</id>
    <published>2020-05-12T06:32:52.000Z</published>
    <updated>2020-05-12T06:39:52.945Z</updated>
    
    <content type="html"><![CDATA[<p><img src="draw_1.png" alt=""></p><ul><li><p><a href="">CoreAnimation</a></p></li><li><p><a href="">CoreGraphics</a>    </p></li><li><p><a href="">OpenGL ES</a> </p></li></ul><h3 id="CoreAnimation"><a href="#CoreAnimation" class="headerlink" title="CoreAnimation"></a>CoreAnimation</h3><p>打开<code>QuartzCore</code>的头文件可以看到,<code>QuartzCore</code>就是引用了<code>CoreAnimation</code>的头文件，所以这两个实际上是同一个，是雌雄同体。。。。<br><code>CoreAnimation</code>中文名核心动画，看名字是负责动画的，其实不然，作用相当大，来看看他的头文件</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COREANIMATION_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COREANIMATION_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QuartzCore/CABase.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QuartzCore/CATransform3D.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __OBJC__</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;QuartzCore/CAAnimation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;QuartzCore/CADisplayLink.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;QuartzCore/CAEAGLLayer.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;QuartzCore/CAEmitterBehavior.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;QuartzCore/CAEmitterCell.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;QuartzCore/CAEmitterLayer.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;QuartzCore/CAGradientLayer.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;QuartzCore/CALayer.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;QuartzCore/CAMediaTiming.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;QuartzCore/CAMediaTimingFunction.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;QuartzCore/CAReplicatorLayer.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;QuartzCore/CAScrollLayer.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;QuartzCore/CAShapeLayer.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;QuartzCore/CATextLayer.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;QuartzCore/CATiledLayer.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;QuartzCore/CATransaction.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;QuartzCore/CATransform3D.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;QuartzCore/CATransformLayer.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;QuartzCore/CAValueFunction.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* COREANIMATION_H */</span></span></span><br></pre></td></tr></table></figure><p>以CA开头的都是他的类，其中带layer的类是构成UIView的基石，用来呈现内容。其中：</p><ul><li>CAShapeLayer<br>用来根据CGPath来渲染的图层，这里CGPath就是上文中提到的CoreGraphics的一部分，比如常做的圆角，都是用cornerRadius来做，但是这是四个角都有的，要想做一个角的就得用他了。</li><li>CATextLayer<br>这个layer可以呈现文字，包含了UILabel的功能，如果你闲的蛋疼，也可以用他来实现一个label。</li><li>CAGradientLayer<br>是用来生成两种或更多颜色平滑渐变的。</li><li>CAReplicatorLayer<br>是为了高效生成许多相似的图层。它会绘制一个或多个图层的子图层，并在每个复制体上应用不同的变换。</li><li>CAScrollLayer<br>有点像UIScrollView，可以用来呈现比他大的内容。</li><li>CATiledLayer<br>Tiled意思的瓷砖，就像铺地板一样，可以把一个很大的图片，切成一格一格的来呈现。</li><li>CAEAGLLayer<br>用来进行OpenGL绘图的工作，需要有OpenGL的基础。</li></ul><p>CAAnimation类继承与NSObject，他是一个抽象类，并不直接负责动画，他有一个子类CAPropertyAnimation，也是抽象类。CAPropertyAnimation的两个子类才直接对layer层进行动画操作，其中CABasicAnimation负责基础动画，CAKeyframeAnimation负责关键帧动画。</p><p>带有Emitter的类是负责粒子动画的类，可以用来做炫酷的粒子动画。</p><p>带有Trans的类负责仿射动画，所谓仿射，就是模仿阳光照射，就有了立体的感觉，可以做三维空间的变换，不像CAAnimation，只能在平面上动手脚。</p><p>CAMediaTiming是一个协议，里边规定了几个属性，用来精确控制时间，animation和layer实现了这个协议。</p><h3 id="CoreGraphics-Quartz2D"><a href="#CoreGraphics-Quartz2D" class="headerlink" title="CoreGraphics/Quartz2D"></a>CoreGraphics/Quartz2D</h3><p>这是一个C语言写就的库,CoreGraphics的类名都是以CG开头的，平时所用的CGRect、CGPoint就在CGGeometry这个几何相关的类中定义，CGFont类则被封装成了UIFont，CGImage构成了UIImage，CGContext是绘图的上下文等等。所以CoreGraphics是系统绘制界面、文字、图像等UI的基础。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COREGRAPHICS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COREGRAPHICS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGBase.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGAffineTransform.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGBitmapContext.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGColor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGColorConversionInfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGColorSpace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGContext.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGDataConsumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGDataProvider.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGError.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGFont.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGFunction.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGGeometry.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGGradient.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGImage.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGLayer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGPDFArray.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGPDFContentStream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGPDFContext.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGPDFDictionary.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGPDFDocument.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGPDFObject.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGPDFOperatorTable.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGPDFPage.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGPDFScanner.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGPDFStream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGPDFString.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGPath.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGPattern.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;CoreGraphics/CGShading.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">/* COREGRAPHICS_H_ */</span></span></span><br></pre></td></tr></table></figure><p>这是一个基于CoreGraphics API的绘图框架，系统中并没有Quartz2D.framework这么一个库，他只是包含了CoreGraphics中的部分API，是一个抽象的引擎，并不是一个实体，他在iOS和MAC系统中负责：</p><ul><li>绘制图形 : 线条\三角形\矩形\圆\弧等</li><li>绘制文字</li><li>绘制\生成图片(图像)</li><li>读取\生成PDF</li><li>截图\裁剪图片</li><li>自定义UI控件</li><li>绘制渐变</li></ul><p>PS：因为是API是C语言写成的，所以ARC并不起作用，仍然需要手动管理内存。</p><h3 id="OpenGL-ES"><a href="#OpenGL-ES" class="headerlink" title="OpenGL ES"></a>OpenGL ES</h3><p>OpenGL ES是应用程序编程接口，该接口描述了方法、结构、函数应具有的行为以及应该如何被使用的语义。也就是说它只定义了一套规范，具体的实现由设备制造商根据规范去做。因为制造商可以自由的实现Open GL ES，所以不同系统实现的OpenGL ES也存在着巨大的性能差异。</p><h3 id="绘图框架"><a href="#绘图框架" class="headerlink" title="绘图框架"></a>绘图框架</h3><p><strong>CoreGraphics/Quartz2D</strong>: QuartZ 2D是苹果公司开发的一套API，它是Core Graphics Framework的一部分，是一套基于C的API框架，使用了Quartz作为绘图引擎。它提供了低级别、轻量级、高保真度的2D渲染。该框架可以用于基于路径的绘图、变换、颜色管理、脱屏渲染，模板、渐变、遮蔽、图像数据管理、图像的创建、遮罩以及PDF文档的创建、显示和分析。<br><strong>OpenGL ES</strong>: OpenGL ES是跨平台的图形API，属于OpenGL的一个简化版本</p><p><strong>Metal</strong>: 进行图像处理的整体框架(苹果新推出的替代OpenGL)</p><p><strong>注意：网上很多人说<code>UIBeizerPath</code>也是绘图框架，我觉得<code>UIBeizerPath</code>只是对<code>CoreGraphics</code>的<code>path</code>做了封装</strong></p><h4 id="上下文？-什么是上下文？"><a href="#上下文？-什么是上下文？" class="headerlink" title="上下文？ 什么是上下文？"></a>上下文？ 什么是上下文？</h4><p>有许多方式获得一个图形上下文，这里我介绍两种最为常用的获取方法。</p><p>第一种方法就是创建一个图片类型的上下文。调用UIGraphicsBeginImageContextWithOptions函数就可获得用来处理图片的图形上下文。利用该上下文，你就可以在其上进行绘图，并生成图片。调用UIGraphicsGetImageFromCurrentImageContext函数可从当前上下文中获取一个UIImage对象。记住在你所有的绘图操作后别忘了调用UIGraphicsEndImageContext函数关闭图形上下文。</p><p>第二种方法是利用cocoa为你生成的图形上下文。当你子类化了一个UIView并实现了自己的drawRect：方法后，一旦drawRect：方法被调用，Cocoa就会为你创建一个图形上下文，此时你对图形上下文的所有绘图操作都会显示在UIView上。</p><p>判断一个上下文是否为当前图形上下文需要注意的几点：<br>1.UIGraphicsBeginImageContextWithOptions函数不仅仅是创建了一个适用于图形操作的上下文，并且该上下文也属于当前上下文。<br>2.当drawRect方法被调用时，UIView的绘图上下文属于当前图形上下文。<br>3.回调方法所持有的context：参数并不会让任何上下文成为当前图形上下文。此参数仅仅是对一个图形上下文的引用罢了。    </p><p>Graphics Context的几种类型</p><ol><li>Bitmap Graphics Context  </li><li>PDF Graphics Context  </li><li>Window Graphics Context  </li><li>Layer Context  </li><li>Post Graphics Context  </li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>iOS绘图框架CoreGraphics分析:<a href="http://www.cocoachina.com/articles/20187" target="_blank" rel="noopener">http://www.cocoachina.com/articles/20187</a><br>傻傻分不清：Quartz2D、QuartzCore、CoreAnimation、CoreImage、CoreGraphics:<a href="https://www.jianshu.com/p/397690fd4555" target="_blank" rel="noopener">https://www.jianshu.com/p/397690fd4555</a><br>iOS图像处理之Core Graphics和OpenGL ES小析:<a href="https://www.jianshu.com/p/f66a7ca326dd" target="_blank" rel="noopener">https://www.jianshu.com/p/f66a7ca326dd</a><br>iOS绘图教程 各种绘制原理：<a href="https://blog.csdn.net/moxi_wang/article/details/48473033" target="_blank" rel="noopener">https://blog.csdn.net/moxi_wang/article/details/48473033</a><br>iOS 图像渲染原理：<a href="http://www.cocoachina.com/cms/wap.php?action=article&id=25510" target="_blank" rel="noopener">http://www.cocoachina.com/cms/wap.php?action=article&amp;id=25510</a><br>iOS端K线系列之绘制方法比较（CoreGraphics、CoreAnimation）:<a href="https://www.jianshu.com/p/ed681ac5c89c" target="_blank" rel="noopener">https://www.jianshu.com/p/ed681ac5c89c</a><br>iOS 图形绘制框架 ——UIBezierPath 、Core Graphics 和OpenGL：<a href="https://www.jianshu.com/p/0cfd271fc6db" target="_blank" rel="noopener">https://www.jianshu.com/p/0cfd271fc6db</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;draw_1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;&quot;&gt;CoreAnimation&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;&quot;&gt;CoreGraphics&lt;/a&gt;    &lt;/p&gt;
&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>Realm使用分析</title>
    <link href="http://yoursite.com/2020/05/12/Realm%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/05/12/Realm%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/</id>
    <published>2020-05-12T05:59:36.000Z</published>
    <updated>2020-05-12T06:00:27.124Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="#Realm">Realm介绍</a></li><li><a href="#Realm数据库">Realm数据库</a><ul><li><a href="#打开数据库">打开数据库</a></li><li><a href="#1配置-realm-数据库">配置 Realm 数据库</a></li><li><a href="#2默认Realm数据库">默认Realm数据库</a></li><li><a href="#3内存中-realm-数据库">内存中realm数据库</a></li><li><a href="#4错误处理">错误处理</a></li><li><a href="#5预植-Realm-数据库">预植 Realm 数据库</a></li></ul></li><li><a href="#常用类">常用类</a></li><li><a href="#数据模型">数据模型</a><ul><li><a href="#1支持的数据类型">支持的数据类型</a></li><li><a href="#2必要属性">必要属性</a></li><li><a href="#3主键">主键</a></li><li><a href="#4索引属性">索引属性</a></li><li><a href="#5被忽略属性">被忽略属性</a></li><li><a href="#6默认属性值">默认属性值</a></li><li><a href="#7属性特性">属性特性</a></li><li><a href="#8属性备忘单">属性备忘单</a></li></ul></li><li><a href="#模型继承">模型继承</a></li><li><a href="#关系">关系</a><ul><li><a href="#1多对一关系">多对一关系</a></li><li><a href="#2多对多关系">多对多关系</a></li><li><a href="#3双向关系">双向关系</a></li></ul></li><li><a href="#数据库操作-增删改查">数据库操作</a><ul><li><a href="#一增">增</a></li><li><a href="#二改">改</a></li><li><a href="#三删">删</a></li><li><a href="#四查">查</a></li></ul></li><li><a href="#数据迁移">数据迁移</a><ul><li><a href="#一本地迁移">本地迁移</a></li><li><a href="#二迁移同步比较复杂不常用">同步迁移</a></li></ul></li></ul><hr><h1 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h1><p><a href="https://realm.io/cn/docs/objc/latest/#using-the-realm-framework" target="_blank" rel="noopener">官方文档</a><br>Realm 数据库是 Realm 移动端数据库容器的一个实例。Realm 数据库可以是本地化的，也可以是可同步的。</p><p>RLM_ARRAY_TYPE 宏创建了一个协议，从而允许您使用 RLMArray<Dog> 这种语法。如果这条宏没有放置在模型接口定义的底部，那么这个模型类就必须前置声明。</p><p>注意，目前暂时不支持对包含原始类型的 RLMArray 进行查询。</p><p>对象的所有更改（添加、修改和删除）都必须在写入事务内完成。</p><p>RLMArray 只能够包含 RLMObject 类型，诸如 NSString 之类的基础类型是无法包含在内的。</p><p>与传统数据库相比，Realm 查询引擎的一个独特特性就是：它能够用很小的事务开销来实现链式查询，而不是每条查询都要接二连三地分别去单独访问数据库服务器。  </p><p>您可以订阅 Realm 通知，以了解 Realm 数据何时发生了更新，比如说可以决定应用 UI 何时进行刷新，而无需重新检索 RLMResults。</p><hr><h2 id="Realm数据库"><a href="#Realm数据库" class="headerlink" title="Realm数据库"></a>Realm数据库</h2><h3 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h3><p>要打开一个 Realm 数据库，首先需要初始化一个新的 <code>RLMRealm</code> 对象：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RLMRealm *realm = [RLMRealm defaultRealm];</span><br><span class="line"></span><br><span class="line">[realm transactionWithBlock:^&#123;</span><br><span class="line">    [realm addObject:mydog];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="1-配置-Realm-数据库"><a href="#1-配置-Realm-数据库" class="headerlink" title="1.配置 Realm 数据库"></a>1.配置 Realm 数据库</h4><p>在打开 <code>Realm</code> 数据库之前，可以对其进行配置。通过创建一个 <code>RLMRealmConfiguration</code> 的对象实例，然后配置相应的属性。通过创建并自定义相关的配置值，使得您可以实现个性化的设置，包括如下方面：</p><ul><li>对于本地 <code>Realm</code> 数据库而言，可以配置 <code>Realm</code> 文件在磁盘上的路径；</li><li>对于可同步 <code>Realm</code> 数据库而言，可以配置管理该 <code>Realm</code> 数据库的用户，以及 <code>Realm</code> 数据库在 <code>Realm</code> 对象服务器上的远程路径；</li><li>对于架构版本之间发生变化的 <code>Realm</code> 数据库而言，可以通过迁移功能来控制旧架构的 <code>Realm</code> 数据该如何更新到最新的架构。</li><li>对于存储的数据量过大、或者数据频繁发生变化的 Realm 数据库而言，可以通过压缩功能来控制 Realm 文件该如何实现压缩，从而确保能高效地利用磁盘空间。<br>要应用配置，可以在每次需要获取 Realm 实例的时候，通过向<code>+[RLMRealm realmWithConfiguration:config error:&amp;err]</code> 方法传递该配置对象，或者通过 <code>[RLMRealmConfiguration setDefaultConfiguration:config]</code> 方法，将默认 Realm 数据库的默认配置设置为我们所需的配置。</li></ul><p>例如，假设有一个应用要求用户必须要登录到 Web 后端服务器中，并且需要支持账户快速切换功能的话。 那么您可以通过以下代码，来为每个账户提供一个独立的 Realm 数据库，并且当前账户所使用的数据库将作为默认 Realm 数据库来使用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SomeClass</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)setDefaultRealmForUser:(<span class="built_in">NSString</span> *)username &#123;</span><br><span class="line">    RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用默认的目录，但是请将文件名替换为用户名</span></span><br><span class="line">    config.fileURL = [[[config.fileURL URLByDeletingLastPathComponent]</span><br><span class="line">                            URLByAppendingPathComponent:username]</span><br><span class="line">                            URLByAppendingPathExtension:<span class="string">@"realm"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将该配置设置为默认 Realm 配置</span></span><br><span class="line">    [RLMRealmConfiguration setDefaultConfiguration:config];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>您可以创建多个配置对象，这样便可以单独控制各个 Realm 数据库的版本、架构以及位置。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取预植数据库文件的 URL</span></span><br><span class="line">config.fileURL = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"MyBundledData"</span> withExtension:<span class="string">@"realm"</span>];</span><br><span class="line"><span class="comment">// 以只读模式打开该文件，这是因为应用的预植数据库是不可写的</span></span><br><span class="line">config.readOnly = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用该配置来打开 Realm 数据库</span></span><br><span class="line">RLMRealm *realm = [RLMRealm realmWithConfiguration:config error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从预植 Realm 数据库中读取某些数据</span></span><br><span class="line">RLMResults&lt;Dog *&gt; *dogs = [Dog objectsInRealm:realm where:<span class="string">@"age &gt; 5"</span>];</span><br></pre></td></tr></table></figure><h4 id="2-默认Realm数据库"><a href="#2-默认Realm数据库" class="headerlink" title="2.默认Realm数据库"></a>2.默认Realm数据库</h4><p>您或许已经注意到，我们是通过调用 <code>[RLMRealm defaultRealm]</code> 来初始化 realm 变量并访问的。这个方法会返回一个 <code>RLMRealm</code> 对象，该对象映射到应用 <code>Documents</code> 文件夹（iOS）或者 <code>Application Support</code> 文件夹（macOS）中的 default.realm 文件。</p><p>Realm API 中的许多方法都存在一个接受 <code>RLMRealm</code> 实例为参数的版本，以及另一个使用默认 <code>Realm</code> 数据库的便利版本。例如，<code>[RLMObject allObjects]</code> 等同于 <code>[RLMObject allObjectsInRealm:[RLMRealm defaultRealm]]</code>。</p><p>请注意，默认的 Realm 构造方法和默认的 Realm 便利方法均不允许进行错误处理；只有在初始化 Realm 数据库不可能失败的情况下，才去使用它们。欲了解更多详情，请参见文档的错误处理部分。</p><h4 id="3-内存中-Realm-数据库"><a href="#3-内存中-Realm-数据库" class="headerlink" title="3.内存中 Realm 数据库"></a>3.内存中 Realm 数据库</h4><p>通过配置 RLMRealmConfiguration 中的 inMemoryIdentifier 属性，而不是 fileURL 属性，这样就能够创建一个完全在内存中运行的 Realm 数据库 (in-memory Realm)，它将不会存储在磁盘当中。设置 inMemoryIdentifier 会将 fileURL 置为 nil（反之亦然）。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line">config.inMemoryIdentifier = <span class="string">@"MyInMemoryRealm"</span>;</span><br><span class="line">RLMRealm *realm = [RLMRealm realmWithConfiguration:config error:<span class="literal">nil</span>];</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>内存中 Realm 数据库无法在应用启动期间存储数据，但是 Realm 数据库的其他功能都能正常使用，包括查询、关系以及线程安全。 如果您需要提供一种灵活的数据访问方式，而不占用磁盘空间的话，那么这是一个很有用的选择。</p><h4 id="4-错误处理"><a href="#4-错误处理" class="headerlink" title="4.错误处理"></a>4.错误处理</h4><p>与任何磁盘 I/O 操作类似，如果资源受到限制，那么创建 RLMRealm 实例有可能会失败。实际上，只有在指定线程中第一次创建 Realm 实例时才可能会发生这种情况。在同一个线程中继续访问 Realm 数据库将会重用缓存的实例，这个操作是不可能失败的。</p><p>为了处理在指定线程中第一次创建 <code>Realm</code> 数据库时所发生的错误，我们提供了一个 <code>NSError</code> 指针类型的 <code>error</code> 参数：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line">RLMRealm *realm = [RLMRealm realmWithConfiguration:config error:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (!realm) &#123;</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-预植-Realm-数据库"><a href="#5-预植-Realm-数据库" class="headerlink" title="5.预植 Realm 数据库"></a>5.预植 Realm 数据库</h4><p>为应用提供一些初始数据的做法非常常见，这样就让用户在首次启动时进行访问。具体做法是：</p><p>1.首先，向 Realm 数据库中植入数据。所使用的数据模型应当与最终发布应用时所使用的 Realm 数据模型相同，然后向数据库中写入所需要的初始数据。由于 Realm 文件是跨平台的，因此您可以使用 macOS 应用（参见我们的 JSONImport 示例）,或者运行在模拟器中的 iOS 应用来完成数据的植入；<br>2.在生成此 Realm 文件的代码中，最后您应当制作一个此数据库的压缩版本（参见 -[RLMRealm writeCopyToPath:error:])）。这可以减少 Realm 文件的大小，使您的应用体积更小，便于用户下载。<br>3.将您 Realm 文件的压缩版本拖曳到应用的 Xcode 项目导航栏中；<br>4.前往 Xcode 中应用目标的 “Build Phases” 选项卡，将 Realm 文件添加到 “Copy Bundle Resources” 构建阶段中。<br>5.此时，应用已经可以访问该预植 Realm 文件 (bundled Realm) 了。您可以使用 <code>[[NSBundle mainBundle] pathForResource:ofType:]</code> 来获取路径；<br>6.如果预植 Realm 数据库中的数据是固定不变、不需要修改的，那么您可以在 <code>RLMRealmConfiguration</code> 对象中，通过设置 readOnly = true 来直接从该路径中打开此文件。否则，如果要对初始数据进行更改的话，您需要使用<code>[[NSFileManager defaultManager] copyItemAtPath:toPath:error:]</code> 将预植文件复制到应用的 Documents 目录下。  </p><hr><h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><ul><li><code>Realm</code> 移动端数据库容器的一个实例</li><li><code>RLMRealmConfiguration</code> 在打开 Realm 数据库之前，可以对其进行配置。通过创建一个 RLMRealmConfiguration 的对象实例，然后配置相应的属性</li><li><code>RLMObject</code></li><li><code>RLMResults</code> 表示<strong>检索</strong>所返回的对象集合。</li><li><code>RLMArray</code> 表示模型之间的<strong>对多关系</strong>。</li><li>RLMLinkingObjects 类，表示模型之间的双向关系](#inverse-relationships)。</li><li>RLMCollection 协议，定义了所有 Realm 集合的常用接口。</li></ul><hr><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><h3 id="1-支持的数据类型"><a href="#1-支持的数据类型" class="headerlink" title="1.支持的数据类型"></a>1.支持的数据类型</h3><p>Realm 支持下述属性类型：<strong><code>BOOL</code></strong>、<strong><code>bool</code></strong>、<strong><code>int</code></strong>、<strong><code>NSInteger</code></strong>、<strong><code>long</code></strong>、<strong><code>long long</code></strong>、<strong><code>float</code></strong>、<strong><code>double</code></strong>、<strong><code>NSString</code></strong>、<strong><code>NSDate</code></strong>、<strong><code>NSData</code></strong> 以及 被特殊类型标记的 <strong><code>NSNumber</code></strong> 。</p><p>CGFloat 属性被取消了，因为它不具备平台独立性。</p><p>您可以使用 <code>RLMArray&lt;Object *&gt;&lt;Object&gt;</code> 和 RLMObject 的相关子类来构建关系模型，诸如一对多、一对一等。</p><p>RLMArray 支持 Objective-C 泛型。下面是不同类型的属性定义含义，以及相关用途：</p><ul><li><code>RLMArray</code> 属性类型。</li><li><code>&lt;Object *&gt;</code> 泛型特化。这可以在编译时防止错误对象类型数组的使用。</li><li><code>&lt;Object&gt;</code> RLMArray 所遵守的协议。可以让 Realm 知晓如何在运行时确定该模型的架构。</li></ul><h3 id="2-必要属性"><a href="#2-必要属性" class="headerlink" title="2.必要属性"></a>2.必要属性</h3><p>通常情况下，NSString *、NSData * 以及 NSDate * 属性可以设置为 nil。如果你必须需要这些值来进行展示的话，那么可以重写 RLMObject 子类的 +requiredProperties 方法。</p><p>例如，对于下述模型定义而言，尝试将 name 属性设置为 nil 将会抛出异常，但是将 birthday 属性设置为 nil 则是允许的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSDate</span> *birthday;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)requiredProperties &#123;</span><br><span class="line">    <span class="keyword">return</span> @[<span class="string">@"name"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用 NSNumber * 属性来存储可空数字。由于对于不同类型的数字而言，Realm 均使用了不同的存储格式，因此该属性必须由 RLMInt、RLMFloat、RLMDouble 或者 RLMBool 所标记。所有赋给该属性的值都会被转换为指定的类型。</p><p>请注意，NSDecimalNumber 值只能够分配给 RLMDouble 属性，并且 Realm 会存储双进度浮点数的近似值，而不是基础的十进制数值。</p><p>如果我们打算存储某人的年龄，而不是存储生日的话，那么还要允许不知道用户年龄的时候，可以将其设置为 nil：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSNumber</span>&lt;RLMInt&gt; *age;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)requiredProperties &#123;</span><br><span class="line">    <span class="keyword">return</span> @[<span class="string">@"name"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><strong>RLMProperty 子类属性始终可以为 nil，因此无法包含在 requiredProperties 当中，此外 RLMArray 不支持存储 nil。</strong></p><h3 id="3-主键"><a href="#3-主键" class="headerlink" title="3.主键"></a>3.主键</h3><p>重写 +primaryKey 可以设置模型的主键。声明主键允许对象的查询和更新更加高效，并且会强制要求每个值保持唯一性。一旦将带有主键的对象添加到 Realm 数据库，那么该对象的主键将无法更改。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSInteger</span> <span class="keyword">id</span>;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">+ (<span class="built_in">NSString</span> *)primaryKey &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"id"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="4-索引属性"><a href="#4-索引属性" class="headerlink" title="4.索引属性"></a>4.索引属性</h3><p>要为某个属性建立索引，那么重写 +indexedProperties 即可。与主键类似，索引会稍微减慢写入速度，但是使用比较运算符进行查询的速度将会更快（它同样会造成 Realm 文件体积的增大，因为需要存储索引。）当您需要为某些特定情况优化读取性能的时候，那么最好添加索引。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Book</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">float</span> price;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *title;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Book</span></span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)indexedProperties &#123;</span><br><span class="line">    <span class="keyword">return</span> @[<span class="string">@"title"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="5-被忽略属性"><a href="#5-被忽略属性" class="headerlink" title="5.被忽略属性"></a>5.被忽略属性</h3><p>如果您不想将模型中的某些字段保存在 Realm 数据库中，那么可以重写 +ignoredProperties。Realm 不会干涉这些属性的正常操作；它们被成员变量所持有，并且可以随意重写它们的 Setter 和 Getter。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSInteger</span> tmpID;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name; <span class="comment">// 只读属性会被自动忽略</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *firstName;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *lastName;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)ignoredProperties &#123;</span><br><span class="line">    <span class="keyword">return</span> @[<span class="string">@"tmpID"</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ %@"</span>, <span class="keyword">self</span>.firstName, <span class="keyword">self</span>.lastName];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>被忽略属性的行为与正常属性完全相同。不过它们不支持 Realm 属性所特有的功能（例如：无法在查询中使用，也无法触发通知）。这些属性仍能够使用 KVO 进行观察。</p><h3 id="6-默认属性值"><a href="#6-默认属性值" class="headerlink" title="6.默认属性值"></a>6.默认属性值</h3><p>重写 <code>+defaultPropertyValues</code>， 可以在每次创建对象时为属性提供默认值。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Book</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">float</span> price;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *title;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Book</span></span></span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)defaultPropertyValues &#123;</span><br><span class="line">    <span class="keyword">return</span> @&#123;<span class="string">@"price"</span> : @<span class="number">0</span>, <span class="string">@"title"</span>: <span class="string">@""</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="7-属性特性"><a href="#7-属性特性" class="headerlink" title="7.属性特性"></a>7.属性特性</h3><p>Realm 将会忽略诸如 <code>nonatomic</code>、<code>atomic</code>、<code>strong</code>、<code>copy</code>、<code>weak</code> 之类的 Objective-C 属性特性。这些特性对于 Realm 存储机制而言并没有意义。Realm 有自己优化过的存储语义。所以为了避免有人对代码产生误解，我们建议您在编写模型时不要附加任何属性特性。不过，如果您切实设置了属性特性，那么在有 <code>RLMObject</code> 被写入到 Realm 数据库之前，这些属性特性都会一直生效。</p><p>无论该 <code>RLMObject</code> 对象是否被 Realm 数据库所管理，Getter 和 Setter 的自定名称仍然可以正常使用。</p><p>由于未被管理的 Realm 对象（即不被 Realm 数据库所管理的 Realm 模型类实例）只是单纯的 NSObject 子类，因此其中的属性特性可以像其他 NSObject 对象一样被观察到。</p><p>如果在 Swift 中使用 Realm Objective-C，那么模型属性需要添加 @objc dynamic var 特性，才能使这些属性能够访问到底层数据库的数据。（您同样可以用 objcMembers 来声明类，然后使用 dynamic var 来声明模型属性。）</p><h3 id="8-属性备忘单"><a href="#8-属性备忘单" class="headerlink" title="8.属性备忘单"></a>8.属性备忘单</h3><p>这个表格提供了声明模型属性的简易参考：</p><table><thead><tr><th>类型</th><th>非可空值形式</th><th>可空值形式</th></tr></thead><tbody><tr><td>Bool</td><td>@property BOOL value;</td><td>@property NSNumber<RLMBool> *value;</td></tr><tr><td>Int</td><td>@property int value;</td><td>@property NSNumber<RLMInt> *value;</td></tr><tr><td>Float</td><td>@property float value;</td><td>@property NSNumber<RLMFloat> *value;</td></tr><tr><td>Double</td><td>@property double value;</td><td>@property NSNumber<RLMDouble> *value;</td></tr><tr><td>String</td><td>@property NSString *value; 1</td><td>@property NSString *value;</td></tr><tr><td>Data</td><td>@property NSData *value; 1</td><td>@property NSData *value;</td></tr><tr><td>Date</td><td>@property NSDate *value; 1</td><td>@property NSDate *value;</td></tr><tr><td>Object</td><td>不存在：必须是可空值</td><td>@property Object *value;</td></tr><tr><td>List</td><td>@property RLMArray&lt;Class *&gt;<Class> *value;</td><td>不存在：必须是非可空值</td></tr><tr><td>LinkingObjects</td><td>@property (readonly) RLMLinkingObjects&lt;Object *&gt; *value; 2</td><td>不存在：必须是非可空值</td></tr></tbody></table><hr><h2 id="模型继承"><a href="#模型继承" class="headerlink" title="模型继承"></a>模型继承</h2><p>Realm 允许对模型进行多级继承，从而允许跨模型实现代码复用，但是某些 Cocoa 特性是没有办法使用的，比如说那些支撑运行时类的多态性的特性。下面是可以实现的操作：  </p><ul><li>父类当中的类方法、实例方法和属性可以被子类继承；</li><li>子类可以使用以父类为参数的方法和函数。</li></ul><p>下列操作目前是无法实现的：  </p><ul><li>多态类之间的强制转换（例如：子类转换为另一个子类，子类转换为父类，父类转换成子类，等等）；</li><li>同时对多个类进行检索；</li><li>包含多个类的容器（RLMArray 以及 RLMResults）。</li></ul><p>此外，如果您的代码实现允许的话，我们建议您使用下述模式，即使用类组合模式来构建子类，从而将其他类当中的逻辑给包含进去：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base Model</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSInteger</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 Animal 一并组合的模型</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Duck</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> Animal *animal;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Duck</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Frog</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> Animal *animal;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSDate</span> *dateProp;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Frog</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line">Duck *duck =  [[Duck alloc] initWithValue:@&#123;<span class="string">@"animal"</span> : @&#123;<span class="string">@"age"</span> : @(<span class="number">3</span>)&#125;, <span class="string">@"name"</span> : <span class="string">@"Gustav"</span> &#125;];</span><br></pre></td></tr></table></figure><hr><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><h4 id="1-多对一关系"><a href="#1-多对一关系" class="headerlink" title="1.多对一关系"></a>1.多对一关系</h4><p>要配置多对一或者一对一关系，在数据模型当中声明一个 RLMObject 子类类型的属性即可：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dog.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="comment">// ... 其余属性声明</span></span><br><span class="line"><span class="keyword">@property</span> Person *owner;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>操作关系属性的方法与其他属性类似：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person *jim = [[Person alloc] init];</span><br><span class="line">Dog    *rex = [[Dog alloc] init];</span><br><span class="line">rex.owner = jim;</span><br></pre></td></tr></table></figure><p>在使用 <code>RLMObject</code> 属性时，您可以使用正常的属性访问语法来访问嵌套属性。例如，<code>rex.owner.address.country</code> 将会遍历对象图，然后自动从 Realm 中检索出每个所需的对象。</p><h4 id="2-多对多关系"><a href="#2-多对多关系" class="headerlink" title="2.多对多关系"></a>2.多对多关系</h4><p>通过 <code>RLMArray</code> 属性，您可以为任意数量的对象或者所支持的原始类型之间构建关系。<code>RLMArray</code> 可以包含其它 <code>RLMObject</code> 类型，也可以包含简单类型的原始值，其接口与 <code>NSMutableArray</code> 非常类似。</p><p><code>RLMArray</code> 所包含的 <code>Realm</code> 对象可能会存储多个相同 Realm 对象的引用，即便对象带有主键也是如此。例如，您或许会创建一个空的 <code>RLMArray</code>，然后连续三次向其中插入同一个对象；每次分别使用 0、1、2 的元素索引来访问的时候，<code>RLMArray</code> 都会返回同一个对象。</p><p><code>RLMArray</code> 可以存储原始类型，从而代替一般的 <code>Realm</code> 对象。为了实现此功能， 请使用下列协议来约束 <code>RLMArray</code>：<code>RLMBool</code>、<code>RLMInt</code>、<code>RLMFloat</code>、<code>RLMDouble</code>、 <code>RLMString</code>、<code>RLMData</code> 或者 <code>RLMDate</code>。</p><p>默认情况下，包含原始类型的 <code>RLMArray</code> 可能也会包含空值（由 <code>NSNull</code> 表示）。 将数组标记为非可空（通过在数组所在的模型对象类型中重写 <code>+requiredProperties:</code>）， 同样也会导致数组当中的值变为非可空。</p><p>让我们给 <code>Person</code> 模型添加一个 <code>dogs</code> 属性，从而让其能够与多个 <code>Dog</code> 对象建立关系。首先，我们需要定义 <code>RLMArray&lt;Dog&gt;</code> 类型，也就是在 <code>Dog</code> 模型接口定义的底部使用这条宏：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dog.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="comment">// ... property declarations</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">RLM_ARRAY_TYPE(Dog) <span class="comment">// 定义 RLMArray&lt;Dog&gt; 类型</span></span><br></pre></td></tr></table></figure><p><code>RLM_ARRAY_TYPE</code> 宏创建了一个协议，从而允许您使用 <code>RLMArray&lt;Dog&gt;</code> 这种语法。如果这条宏没有放置在模型接口定义的底部，那么这个模型类就必须前置声明。</p><p>接下来，您就可以声明 <code>RLMArray&lt;Dog&gt;</code> 类型的属性了：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="comment">// ...其他属性声明</span></span><br><span class="line"><span class="keyword">@property</span> RLMArray&lt;Dog *&gt;&lt;Dog&gt; *dogs;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>您可以照常对 RLMArray 属性进行访问和赋值：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Jim 是 Rex 和所有名为 "Fido" 狗狗的主人</span></span><br><span class="line">RLMResults&lt;Dog *&gt; *someDogs = [Dog objectsWhere:<span class="string">@"name contains 'Fido'"</span>];</span><br><span class="line">[jim.dogs addObjects:someDogs];</span><br><span class="line">[jim.dogs addObject:rex];</span><br></pre></td></tr></table></figure><p>注意，虽然可以给 <code>RLMArray</code> 属性赋值为 nil，但是这仅仅只会“清空”该数组，而不会将该数组给移除。这意味着您永远都可以向 <code>RLMArray</code> 属性中添加对象，即便其之前曾被置为 nil。</p><p><code>RLMArray</code> 属性会确保其内部的插入次序不会被打乱。</p><p><strong>注意，目前暂时不支持对包含原始类型的 RLMArray 进行查询。</strong></p><h4 id="3-双向关系"><a href="#3-双向关系" class="headerlink" title="3.双向关系"></a>3.双向关系</h4><p>关系是单向的。以 <code>Person</code> 和 <code>Dog</code> 这两个类为例。如果 <code>Person.dogs</code> 连接了一个 Dog 实例，那么您可以随着该连接从 <code>Person</code> 访问到对应的 <code>Dog</code>，但是是没有办法从 <code>Dog</code> 访问到对应的 <code>Person</code> 对象的。您可以设置一个一对一属性 <code>Dog.owner</code> 从而连接到 <code>Person</code>，但是这些连接实际上仍然是互相独立的。<strong>给 <code>Person.dogs</code> 添加一个 <code>Dog</code> 对象并不会将该对象的 <code>Dog.owner</code> 属性设置为对应的 <code>Person</code>。为了解决这个问题，Realm 提供了连接对象属性，从而表示这种双向关系</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSInteger</span> age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) RLMLinkingObjects *owners;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Dog</span></span></span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)linkingObjectsProperties &#123;</span><br><span class="line">    <span class="keyword">return</span> @&#123;</span><br><span class="line">        <span class="string">@"owners"</span>: [RLMPropertyDescriptor descriptorWithClass:Person.class propertyName:<span class="string">@"dogs"</span>],</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>借助连接对象属性，可以从特定属性获取连接到指定对象的所有对象。Dog 对象可以拥有一个名为 owners 属性，它包含所有 dogs 属性有该 Dog 对象的 Person 对象。将这个 owners 属性设置为 RLMLinkingObjects 类型，然后重写 +[RLMObject linkingObjectsProperties] 来表示 owners 与 Person 模型对象之间的关系。</p><hr><h2 id="数据库操作-增删改查"><a href="#数据库操作-增删改查" class="headerlink" title="数据库操作-增删改查"></a>数据库操作-增删改查</h2><h3 id="一-增"><a href="#一-增" class="headerlink" title="(一)增"></a>(一)增</h3><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>当定义完数据模型之后，就可以实例化 RLMObject 子类了， 然后还可以向 Realm 数据库中添加新的实例</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dog 数据模型</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSInteger</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Implementation</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Dog</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>创建新对象的方法有很多种：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1) 创建 Dog 对象，然后设置其属性</span></span><br><span class="line">Dog *myDog = [[Dog alloc] init];</span><br><span class="line">myDog.name = <span class="string">@"Rex"</span>;</span><br><span class="line">myDog.age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 从字典中创建 Dog 对象</span></span><br><span class="line">Dog *myOtherDog = [[Dog alloc] initWithValue:@&#123;<span class="string">@"name"</span> : <span class="string">@"Pluto"</span>, <span class="string">@"age"</span> : @<span class="number">3</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) 从数组中创建 Dog 对象</span></span><br><span class="line">Dog *myThirdDog = [[Dog alloc] initWithValue:@[<span class="string">@"Pluto"</span>, @<span class="number">3</span>]];</span><br></pre></td></tr></table></figure><p>对象创建之后，您就可以将其添加到 Realm 数据库了：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取默认的 Realm 数据库</span></span><br><span class="line">RLMRealm *realm = [RLMRealm defaultRealm];</span><br><span class="line"><span class="comment">// （每个线程）只需执行一次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在事务中向 Realm 数据库中添加数据</span></span><br><span class="line">[realm beginWriteTransaction];</span><br><span class="line">[realm addObject:myDog];</span><br><span class="line">[realm commitWriteTransaction];</span><br></pre></td></tr></table></figure><h3 id="二-改"><a href="#二-改" class="headerlink" title="(二)改"></a>(二)改</h3><p>将对象添加到 Realm 数据库之后，您仍然可以继续使用它，并且对其进行的所有更改都会被存储（必须要在写入事务当中进行）。当写入事务提交之后，其他使用同一个 Realm 数据库的线程所做的更改都可以继续进行。</p><h4 id="1-直接更新"><a href="#1-直接更新" class="headerlink" title="1.直接更新"></a>1.直接更新</h4><p>您可以在写入事务中，通过设置对象的属性从而完成更新。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在事务中更新对象</span></span><br><span class="line">[realm beginWriteTransaction];</span><br><span class="line">author.name = <span class="string">@"Thomas Pynchon"</span>;</span><br><span class="line">[realm commitWriteTransaction];</span><br></pre></td></tr></table></figure><h4 id="2-键值编码"><a href="#2-键值编码" class="headerlink" title="2.键值编码"></a>2.键值编码</h4><p>RLMObject、RLMResult 和 RLMArray 均允许使用 键值编码(KVC)。 当您需要在运行时决定何种属性需要进行更新的时候， 这个方法就非常有用了。</p><p><strong>批量更新对象时，为集合实现 KVC 是一个很好的做法， 这样就不用承受遍历集合时为每个项目创建访问器 所带来的性能损耗。</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RLMResults&lt;Person *&gt; *persons = [Person allObjects];</span><br><span class="line">[[RLMRealm defaultRealm] transactionWithBlock:^&#123;</span><br><span class="line">    [[persons firstObject] setValue:@YES forKeyPath:<span class="string">@"isFirst"</span>];</span><br><span class="line">    <span class="comment">// 将每个 person 对象的 planet 属性设置为 "Earth"</span></span><br><span class="line">    [persons setValue:<span class="string">@"Earth"</span> forKeyPath:<span class="string">@"planet"</span>];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="3-通过主键更新"><a href="#3-通过主键更新" class="headerlink" title="3.通过主键更新"></a>3.通过主键更新</h4><p>如果数据模型类中包含了主键，那么 可以使用 -[RLMRealm addOrUpdateObject:]，从而让 Realm 基于主键来自动更新或者添加对象。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 book 对象，其主键与之前存储的 book 对象相同</span></span><br><span class="line">Book *cheeseBook = [[Book alloc] init];</span><br><span class="line">cheeseBook.title = <span class="string">@"Cheese recipes"</span>;</span><br><span class="line">cheeseBook.price = @<span class="number">9000</span>;</span><br><span class="line">cheeseBook.id = @<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新这个 id = 1 的 book</span></span><br><span class="line">[realm beginWriteTransaction];</span><br><span class="line">[realm addOrUpdateObject:cheeseBook];</span><br><span class="line">[realm commitWriteTransaction];</span><br></pre></td></tr></table></figure><p>如果这个主键值为 “1” 的 Book 对象已经存在于数据库当中 ，那么该对象只会进行更新。如果不存在的话， 那么一个全新的 Book 对象就会被创建出来，并被添加到数据库当中。</p><p>您可以通过传递一个子集，其中只包含打算更新的值， 从而对带有主键的对象进行部分更新：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设主键为 `1` 的 "Book" 对象已经存在</span></span><br><span class="line">[realm beginWriteTransaction];</span><br><span class="line">[Book createOrUpdateInRealm:realm withValue:@&#123;<span class="string">@"id"</span>: @<span class="number">1</span>, <span class="string">@"price"</span>: @<span class="number">9000.0</span>f&#125;];</span><br><span class="line"><span class="comment">// book 对象的 `title` 属性仍旧保持不变</span></span><br><span class="line">[realm commitWriteTransaction];</span><br></pre></td></tr></table></figure><p><strong>如果没有定义主键，那么最好不要对这类对象调用本节中所示的方法（也就是这些以 OrUpdate 结尾的方法）。</strong></p><h3 id="三-删"><a href="#三-删" class="headerlink" title="(三)删"></a>(三)删</h3><p>在写入事务中，将要删除的对象传递给 -[RLMRealm deleteObject:] 方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cheeseBook 存储在 Realm 数据库中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在事务中删除对象</span></span><br><span class="line">[realm beginWriteTransaction];</span><br><span class="line">[realm deleteObject:cheeseBook];</span><br><span class="line">[realm commitWriteTransaction];</span><br></pre></td></tr></table></figure><p>您同样也可以删除存储在 Realm 数据库当中的所有数据。请注意，Realm 文件会保留在磁盘上所占用的空间，从而为以后的对象预留足够的空间，从而实现快速存储。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 Realm 数据库中删除所有对象</span></span><br><span class="line">[realm beginWriteTransaction];</span><br><span class="line">[realm deleteAllObjects];</span><br><span class="line">[realm commitWriteTransaction];</span><br></pre></td></tr></table></figure><h3 id="四-查"><a href="#四-查" class="headerlink" title="(四)查"></a>(四)查</h3><p>查询将会返回一个 RLMResults 实例，其中包含了一组 RLMObject 对象。RLMResults 的接口与 NSArray 基本相同，并且可以使用索引下标来访问包含在 RLMResults 当中的对象。与 NSArray 所不同的是，RLMResults 中元素的类型是固定的，并且只能持有一个 RLMObject 子类类型。</p><p>从 Realm 数据库中检索对象的最基本方法是 +[RLMObject allObjects]，这个方法将会返回 RLMObject 子类类型在默认 Realm 数据库当中的查询到的所有数据，并以 RLMResults 实例的形式返回。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RLMResults&lt;Dog *&gt; *dogs = [Dog allObjects]; <span class="comment">// 从默认的 Realm 数据库中遍历所有 Dog 对象</span></span><br></pre></td></tr></table></figure><h4 id="1-条件查询"><a href="#1-条件查询" class="headerlink" title="1.条件查询"></a>1.条件查询</h4><p>如果您对 NSPredicate 有所了解的话，那么您就已经掌握了在 Realm 中进行查询的方法了。RLMObjects、RLMRealm、RLMArray 和 RLMResults 均提供了相关的方法，从而只需传递 NSPredicate 实例、断言字符串、或者断言格式化字符串来查询特定的 RLMObject 实例，这与对 NSArray 进行查询所类似。</p><p>例如，下面这个例子通过调用 [RLMObject objectsWhere:] 方法，从默认 Realm 数据库中遍历出所有棕黄色、名字以 “B” 开头的狗狗：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用断言字符串来查询</span></span><br><span class="line">RLMResults&lt;Dog *&gt; *tanDogs = [Dog objectsWhere:<span class="string">@"color = 'tan' AND name BEGINSWITH 'B'"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 NSPredicate 来查询</span></span><br><span class="line"><span class="built_in">NSPredicate</span> *pred = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"color = %@ AND name BEGINSWITH %@"</span>,</span><br><span class="line">                                                     <span class="string">@"tan"</span>, <span class="string">@"B"</span>];</span><br><span class="line">tanDogs = [Dog objectsWithPredicate:pred];</span><br></pre></td></tr></table></figure><p>Realm 支持大多数常见的断言：</p><ul><li>比较操作数可以是属性名，也可以是常量。但至少要有一个操作数是属性名；</li><li>比较操作符 ==、&lt;=、&lt;、&gt;=、&gt;、!= 和 BETWEEN 支持 int、long、long long、float、double 以及 NSDate 这几种属性类型，例如 age == 45；</li><li>比较是否相同：== 和 !=，例如，[Employee objectsWhere:@”company == %@”, company]；</li><li>比较操作符 == 和 != 支持布尔属性；</li><li>对于 NSString 和 NSData 属性而言，支持使用 ==、!=、BEGINSWITH、CONTAINS 和 ENDSWITH 操作符，例如 name CONTAINS ‘Ja’；</li><li>对于 NSString 属性而言，LIKE 操作符可以用来比较左端属性和右端表达式：? 和 * 可用作通配符，其中 ? 可以匹配任意一个字符，* 匹配 0 个及其以上的字符。例如：value LIKE ‘?bc*’ 可以匹配到诸如 “abcde” 和 “cbc” 之类的字符串；</li><li>字符串的比较忽略大小写，例如 name CONTAINS[c] ‘Ja’。请注意，只有 “A-Z” 和 “a-z” 之间的字符大小写会被忽略。[c] 修饰符可以与 [d] 修饰符结合使用；</li><li>字符串的比较忽略变音符号，例如 name BEGINSWITH[d] ‘e’ 能够匹配到 étoile。这个修饰符可以与 [c] 修饰符结合使用。（这个修饰符只能够用于 Realm 所支持的字符串子集：参见当前的限制一节来了解详细信息。）</li><li>Realm 支持以下组合操作符：“AND”、“OR” 和 “NOT”，例如 name BEGINSWITH ‘J’ AND age &gt;= 32；</li><li>包含操作符：IN，例如 name IN {‘Lisa’, ‘Spike’, ‘Hachi’}；</li><li>空值比较：==、!=，例如 [Company objectsWhere:@”ceo == nil”]。请注意，Realm 将 nil 视为一种特殊值，而不是某种缺失值；这与 SQL 不同，nil 等同于自身；</li><li>ANY 比较，例如 ANY student.age &lt; 21；</li><li>RLMArray 和 RLMResults 属性支持聚集表达式：@count、@min、@max、@sum 和 @avg，例如 [Company objectsWhere:@”employees.@count &gt; 5”] 可用以检索所有拥有 5 名以上雇员的公司。</li><li>支持子查询，不过存在以下限制：<ul><li>@count 是唯一一个能在 SUBQUERY 表达式当中使用的操作符；</li><li>SUBQUERY(…).@count 表达式只能与常量相比较；</li><li>目前仍不支持关联子查询。</li></ul></li></ul><h4 id="2-排序"><a href="#2-排序" class="headerlink" title="2.排序"></a>2.排序</h4><p>RLMResults 允许您指定一个排序标准，然后基于<strong><code>关键路径</code></strong>、<strong><code>属性</code></strong>或者多个<strong><code>排序描述符</code></strong>来进行排序。例如，下列代码让上述示例中返回的 Dog 对象按名字进行升序排序：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对颜色为棕黄色、名字以 "B" 开头的狗狗进行排序</span></span><br><span class="line">RLMResults&lt;Dog *&gt; *sortedDogs = [[Dog objectsWhere:<span class="string">@"color = 'tan' AND name BEGINSWITH 'B'"</span>]</span><br><span class="line">                                    sortedResultsUsingKeyPath:<span class="string">@"name"</span> ascending:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><p>关键路径同样也可以是某个多对一关系属性。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RLMResults&lt;Person *&gt; *dogOwners = [Person allObjects];</span><br><span class="line">RLMResults&lt;Person *&gt; *ownersByDogAge = [dogOwners sortedResultsUsingKeyPath:<span class="string">@"dog.age"</span> ascending:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><p>请注意，<code>sortedResultsUsingKeyPath:</code> 和 <code>sortedResultsUsingProperty:</code> 不支持 将多个属性用作排序基准，此外也无法链式排序（只有最后一个 sortedResults… 调用会被使用）。 如果要对多个属性进行排序，请使用 <code>sortedResultsUsingDescriptors:</code>，然后向其中输入多个 RLMSortDescriptor` 对象。</p><h4 id="3-链式查询"><a href="#3-链式查询" class="headerlink" title="3.链式查询"></a>3.链式查询</h4><p>与传统数据库相比，Realm 查询引擎的一个独特特性就是：它能够用很小的事务开销来实现链式查询，而不是每条查询都要接二连三地分别去单独访问数据库服务器。</p><p>如果您需要获取一个棕黄色狗狗的结果集，然后在此基础上再获取名字以 ‘B’ 开头的棕黄色狗狗，那么您可以像这样将这两个查询连接起来：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RLMResults&lt;Dog *&gt; *tanDogs = [Dog objectsWhere:<span class="string">@"color = 'tan'"</span>];</span><br><span class="line">RLMResults&lt;Dog *&gt; *tanDogsWithBNames = [tanDogs objectsWhere:<span class="string">@"name BEGINSWITH 'B'"</span>];</span><br></pre></td></tr></table></figure><h4 id="4-结果的自更新"><a href="#4-结果的自更新" class="headerlink" title="4.结果的自更新"></a>4.结果的自更新</h4><p>RLMObject 实例是底层数据的动态体现，其会自动进行更新，这意味着您无需去重新检索结果。它们会直接映射出 Realm 数据库在当前线程中的状态，包括当前线程上的写入事务。唯一的例外是，在使用 for…in 枚举时，它会将刚开始遍历时满足匹配条件的所有对象给遍历完，即使在遍历过程中有对象被过滤器修改或者删除。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RLMResults&lt;Dog *&gt; *puppies = [Dog objectsInRealm:realm where:<span class="string">@"age &lt; 2"</span>];</span><br><span class="line">puppies.count; <span class="comment">// =&gt; 0</span></span><br><span class="line"></span><br><span class="line">[realm transactionWithBlock:^&#123;</span><br><span class="line">    [Dog createInRealm:realm withValue:@&#123;<span class="string">@"name"</span>: <span class="string">@"Fido"</span>, <span class="string">@"age"</span>: @<span class="number">1</span>&#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">puppies.count; <span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure><h4 id="5-限制查询结果"><a href="#5-限制查询结果" class="headerlink" title="5.限制查询结果"></a>5.限制查询结果</h4><p>大多数其他数据库技术都提供了从检索中对结果进行“分页”的能力（例如 SQLite 中的 “LIMIT” 关键字）。这通常是很有必要的，可以避免一次性从硬盘中读取太多的数据，或者将太多查询结果加载到内存当中。</p><p><strong><code>由于 Realm 中的检索是惰性的，因此这行这种分页行为是没有必要的</code></strong>。因为 Realm 只会在检索到的结果被明确访问时，才会从其中加载对象。</p><p>如果由于 UI 相关或者其他代码实现相关的原因导致您需要从检索中获取一个特定的对象子集，这和获取 RLMResults 对象一样简单，只需要读出您所需要的对象即可。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环读取出前 5 个 Dog 对象</span></span><br><span class="line"><span class="comment">// 从而限制从磁盘中读取的对象数量</span></span><br><span class="line">RLMResults&lt;Dog *&gt; *dogs = [Dog allObjects];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    Dog *dog = dogs[i];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h2><h3 id="一-本地迁移"><a href="#一-本地迁移" class="headerlink" title="(一)本地迁移"></a>(一)本地迁移</h3><p>通过设置 RLMRealmConfiguration.schemaVersion 以及 RLMRealmConfiguration.migrationBlock 可以定义本地迁移。迁移模块将提供所有的逻辑操作，以便将数据模型从之前的架构转换为新的架构。每当用配置对象创建完 RLMRealm 之后，如果需要进行迁移的话，那么迁移模块就会将 RLMRealm 更新至指定的架构版本。<br>假设我们需要将上面所声明的 Person 模型进行迁移。下述代码是最精简的数据模块：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此段代码位于 [AppDelegate didFinishLaunchingWithOptions:]</span></span><br><span class="line"></span><br><span class="line">RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line"><span class="comment">// 设置新的架构版本。必须大于之前所使用的版本</span></span><br><span class="line"><span class="comment">// （如果之前从未设置过架构版本，那么当前的架构版本为 0）</span></span><br><span class="line">config.schemaVersion = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置模块，如果 Realm 的架构版本低于上面所定义的版本，</span></span><br><span class="line"><span class="comment">// 那么这段代码就会自动调用</span></span><br><span class="line">config.migrationBlock = ^(RLMMigration *migration, uint64_t oldSchemaVersion) &#123;</span><br><span class="line">    <span class="comment">// 我们目前还未执行过迁移，因此 oldSchemaVersion == 0</span></span><br><span class="line">    <span class="keyword">if</span> (oldSchemaVersion &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有什么要做的！</span></span><br><span class="line">        <span class="comment">// Realm 会自行检测新增和被移除的属性</span></span><br><span class="line">        <span class="comment">// 然后会自动更新磁盘上的架构</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知 Realm 为默认的 Realm 数据库使用这个新的配置对象</span></span><br><span class="line">[RLMRealmConfiguration setDefaultConfiguration:config];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在我们已经通知了 Realm 如何处理架构变化，</span></span><br><span class="line"><span class="comment">// 打开文件将会自动执行迁移</span></span><br><span class="line">[RLMRealm defaultRealm];</span><br></pre></td></tr></table></figure><h4 id="1-值的更新"><a href="#1-值的更新" class="headerlink" title="1.值的更新"></a>1.值的更新</h4><p>虽然这个迁移操作是最精简的了，但是我们需要让这个闭包能够自行计算新的属性（这里指的是 fullName），这样才有意义。 在迁移模块中，我们能够调用 [RLMMigration enumerateObjects:block:] 来枚举特定类型的每个 RLMObject 对象，然后执行必要的迁移逻辑。注意，对枚举中每个已存在的 RLMObject 实例来说，应该是通过访问 oldObject 对象进行访问，而更新之后的实例应该通过 newObject 进行访问：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此段代码位于 [AppDelegate didFinishLaunchingWithOptions:]</span></span><br><span class="line"></span><br><span class="line">RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line">config.schemaVersion = <span class="number">1</span>;</span><br><span class="line">config.migrationBlock = ^(RLMMigration *migration, uint64_t oldSchemaVersion) &#123;</span><br><span class="line">    <span class="comment">// 我们目前还未执行过迁移，因此 oldSchemaVersion == 0</span></span><br><span class="line">    <span class="keyword">if</span> (oldSchemaVersion &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// enumerateObjects:block: 方法将会遍历</span></span><br><span class="line">        <span class="comment">// 所有存储在 Realm 文件当中的 `Person` 对象</span></span><br><span class="line">        [migration enumerateObjects:Person.className</span><br><span class="line">                              block:^(RLMObject *oldObject, RLMObject *newObject) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将两个 name 合并到 fullName 当中</span></span><br><span class="line">        newObject[<span class="string">@"fullName"</span>] = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ %@"</span>,</span><br><span class="line">                                      oldObject[<span class="string">@"firstName"</span>],</span><br><span class="line">                                      oldObject[<span class="string">@"lastName"</span>]];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">[RLMRealmConfiguration setDefaultConfiguration:config];</span><br></pre></td></tr></table></figure><p>一旦迁移成功结束，Realm 文件和其中的所有对象都可被您的应用正常访问。</p><h4 id="2-属性重命名"><a href="#2-属性重命名" class="headerlink" title="2.属性重命名"></a>2.属性重命名</h4><p>在迁移过程中对类中某个属性进行重命名操作， 比起拷贝值和保留关系来说要更为高效。</p><p>要在迁移过程中对某个属性就进行重命名的话，请确保您的新模型当中的这个属性是一个全新的名字， 它的名字不能和原有模型当中的名字重合。</p><p>如果新的属性拥有不同的可空性或者索引设置的话， 这些配置会在重命名操作期间生效。</p><p>下面是一个例子，展示了您该如何将 Person 的 yearsSinceBirth 属性重命名为 age 属性：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此段代码位于 [AppDelegate didFinishLaunchingWithOptions:]</span></span><br><span class="line"></span><br><span class="line">RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line">config.schemaVersion = <span class="number">1</span>;</span><br><span class="line">config.migrationBlock = ^(RLMMigration *migration, uint64_t oldSchemaVersion) &#123;</span><br><span class="line">    <span class="comment">// 我们目前还未执行过迁移，因此 oldSchemaVersion == 0</span></span><br><span class="line">    <span class="keyword">if</span> (oldSchemaVersion &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 重命名操作必须要在 `enumerateObjects:` 调用之外进行</span></span><br><span class="line">        [migration renamePropertyForClass:Person.className oldName:<span class="string">@"yearsSinceBirth"</span> newName:<span class="string">@"age"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">[RLMRealmConfiguration setDefaultConfiguration:config];</span><br></pre></td></tr></table></figure><h4 id="3-线性迁移"><a href="#3-线性迁移" class="headerlink" title="3.线性迁移"></a>3.线性迁移</h4><p>假如说，我们的应用有两个用户： JP 和 Tim。JP 经常更新应用，但 Tim 却经常跳过某些版本。所以 JP 可能下载过这个应用的每一个版本，并且一步一步地跟着更新构架：第一次下载更新后，数据库架构从 v0 更新到 v1；第二次架构从 v1 更新到 v2…以此类推，井然有序。相反，Tim 很有可能直接从 v0 版本直接跳到了 v2 版本。 因此，您应该使用非嵌套的 if (oldSchemaVersion &lt; X) 结构来构造您的数据库迁移模块，以确保无论用户在使用哪个版本的架构，都能完成必需的更新。</p><p>当您的用户不按套路出牌，跳过有些更新版本的时候，另一种情况也会发生。假如您在 v2 里删掉了一个 “email” 属性，然后在 v3 里又把它重新引进了。假如有个用户从 v1 直接跳到 v3，那 Realm 不会自动检测到 v2 的这个删除操作，因为存储的数据架构和代码中的架构吻合。这会导致 Tim 的 Person 对象有一个 v3 的 email 属性，但里面的内容却是 v1 的。这个看起来没什么大问题，但是假如两者的内部存储类型不同（比如说： 从 ISO email 标准格式变成了自定义格式），那麻烦就大了。为了避免这种不必要的麻烦，我们推荐您在 if (oldSchemaVersion &lt; 3) 语句中，清空所有的 email 属性。</p><h3 id="（二）迁移同步-比较复杂不常用"><a href="#（二）迁移同步-比较复杂不常用" class="headerlink" title="（二）迁移同步(比较复杂不常用)"></a>（二）迁移同步(比较复杂不常用)</h3><p>当 Realm 数据库与 Realm 对象服务器同步时，迁移过程会有所不同——在很多情况下，其实会更加简单。下面是您所需要知晓的全部内容：</p><ul><li>无需设置架构版本（尽管您可以这样做）；</li><li>新增内容的更改会自动进行，例如添加类或者向类中添加字段；</li><li>从架构中将某个字段移除并不会从数据库中删除该字段，而是指示 Realm 忽略该字段。新的对象创建的时候仍然会使用这些属性，但是它们都将会被设置为 null。不可空的字段将被恰当地设置为零/空值：数字字段将被置为 0，字符串属性将被置为空字符串，等等。</li><li>您不能添加迁移模块。<br>假设您的应用中有一个 Dog 类：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>现在您需要添加 Person 类，并建立一个到 Dog 的 owner 关系。除了添加类和相关属性之外，在同步之前您无需执行任何操作：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> Person   *owner;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">RLM_ARRAY_TYPE(Dog)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSDate</span>   *birthdate;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">RLM_ARRAY_TYPE(Person)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Objecitve-C 引用类型的非可空属性</span></span><br><span class="line"><span class="comment">// 必须以这种形式进行声明：</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)requiredProperties &#123;</span><br><span class="line">    <span class="keyword">return</span> @[<span class="string">@"name"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURL</span> *syncServerURL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://localhost:9080/Dogs"</span>];</span><br><span class="line">RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line">config.syncConfiguration = [[RLMSyncConfiguration alloc] initWithUser:user realmURL:syncServerURL];</span><br><span class="line"></span><br><span class="line">RLMRealm *realm = [RLMRealm realmWithConfiguration:config error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>由于可同步 Realm 数据库不支持迁移模块，因此迁移当中的破坏性更改——例如主键更改、既有字段的字段类型更改（同时保留相同的名称），以及将属性从可空更改为非可空，诸如此类的操作，都需要用另外的方式来进行处理。创建一个新的具备新架构的可同步 Realm 数据库，然后将数据从旧的 Realm 数据库复制到新的 Realm 数据库：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> Person *owner;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">RLM_ARRAY_TYPE(Dog)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">RLM_ARRAY_TYPE(Person)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)requiredProperties &#123;</span><br><span class="line">    <span class="keyword">return</span> @[<span class="string">@"name"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PersonV2</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">RLM_ARRAY_TYPE(PersonV2)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PersonV2</span></span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)requiredProperties &#123;</span><br><span class="line">    <span class="keyword">return</span> @[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURL</span> *syncServerURL = [<span class="built_in">NSURL</span> URLWithString: <span class="string">@"realm://localhost:9080/Dogs"</span>];</span><br><span class="line">RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line">config.syncConfiguration = [[RLMSyncConfiguration alloc] initWithUser:user realmURL:syncServerURL];</span><br><span class="line"><span class="comment">// 限制初始对象类型</span></span><br><span class="line">config.objectClasses = @[Dog.class, Person.class];</span><br><span class="line"></span><br><span class="line">RLMRealm *initialRealm = [RLMRealm realmWithConfiguration:config error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">syncServerURL = [<span class="built_in">NSURL</span> URLWithString: <span class="string">@"realm://localhost:9080/DogsV2"</span>];</span><br><span class="line">config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line">config.syncConfiguration = [[RLMSyncConfiguration alloc] initWithUser:user realmURL:syncServerURL];</span><br><span class="line"><span class="comment">// 限制新对象类型</span></span><br><span class="line">config.objectClasses = @[Dog.class, PersonV2.class];</span><br><span class="line"></span><br><span class="line">RLMRealm *newRealm = [RLMRealm realmWithConfiguration:config error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>此外，对于可同步 Realm 数据库而言，还可以在客户端上编写一个通知处理器，或者使用 Node.js SDK 在服务器上编写一段 JavaScript 函数（如果您所使用的对象服务器版本支持的话），来执行自定义迁移。但是，如果迁移过程中出现了破坏性更改，那么 Realm 将停止与 Realm 对象服务器进行同步，并产生 Bad changeset received 错误。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#Realm&quot;&gt;Realm介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#Realm数据库&quot;&gt;Realm数据库&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#打开数据库&quot;&gt;打开数据库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#1配置-re
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>FMDB使用分析</title>
    <link href="http://yoursite.com/2020/05/12/FMDB%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/05/12/FMDB%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/</id>
    <published>2020-05-12T05:57:41.000Z</published>
    <updated>2020-05-12T05:58:19.253Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、基本介绍"><a href="#一、基本介绍" class="headerlink" title="一、基本介绍"></a>一、基本介绍</h3><ul><li>什么是FMDB  </li></ul><p>– FMDB是iOS平台的SQLite数据库框架<br>– FMDB以OC的方式封装了SQLite的C语言API</p><ul><li>FMDB常用类：  </li></ul><p>– <strong>FMDatabase</strong>：一个FMDatabase对象就代表一个单独的SQLite数据库用来执行SQL语句<br>– <strong>FMResultSet</strong>：使用FMDatabase执行查询后的结果集<br>– <strong>FMDatabaseQueue</strong>：用于在多线程中执行多个查询或更新，它是线程安全的  </p><ul><li>FMDB的优点  </li></ul><p>– 使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码<br>– 对比苹果自带的Core Data框架，更加轻量级和灵活<br>– 提供了多线程安全的数据库操作方法，有效地防止数据混乱</p><ul><li>FMDB的缺点  </li></ul><p>– 它本身也存在一些问题，比如跨平台，因为它是用oc的语言封装的，所以<br>只能在ios开发的时候使用，如果想实现跨平台的操作，来降低开发的成本<br>和维护的成本,就需要使用比较原始的SQLite。</p><h3 id="二、使用方法"><a href="#二、使用方法" class="headerlink" title="二、使用方法"></a>二、使用方法</h3><ul><li><p>打开数据库<br>通过指定SQLite数据库文件路径来创建FMDatabase对象</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FMDatabase *db = [FMDatabase databaseWithPath:path];</span><br><span class="line"><span class="keyword">if</span> (![db open]) &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"数据库打开失败！"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于文件路径的三种情况：</p><blockquote><p>1.具体的文件路径,或是数据库的文件不存在时,fmdb会自己创建一个。<br>2.若文件路径为空字符串@””，会在临时目录创建一个空的数据库。<br>并且，当(FMDatabase)数据库断开连接时，数据库文件被删除。<br>3.若你传入的参数为NULL，则它会建立一个在内存中的数据库，数据库断开连接时，数据库文件被删除。  </p></blockquote></li><li><p>执行更新：<br>在FMDB中,除查询以外的所有操作,都称为“更新”如：create、drop、insert、update、delete等。<br>FMDB数据库操作使用 executeUpdate: 方法执行更新,返回BOOL型。 </p></li></ul><p>executeUpdate:用法  </p><blockquote><p>-(BOOL)executeUpdate:(NSString)sql, …<br>-(BOOL)executeUpdateWithFormat:(NSString)format, …<br>-(BOOL)executeUpdate:(NSString*)sql withArgumentsInArray:(NSArray *)arguments<br>示例<br>[db executeUpdate:@”UPDATE t_student SET age = ? WHERE name = ?;”, @20, @”Jack”]</p></blockquote><ul><li>执行查询<br>查询方法<blockquote><p>-(FMResultSet )executeQuery: (NSString)sql, …<br>-(FMResultSet )executeQueryWithFormat:(NSString)format, …<br>-(FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray *)arguments  </p></blockquote></li></ul><p>示例</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询数据</span></span><br><span class="line">FMResultSet *rs = [db executeQuery:<span class="string">@"SELECT * FROM t_student"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历结果集</span></span><br><span class="line"><span class="keyword">while</span> ([rs next]) &#123; </span><br><span class="line">  <span class="built_in">NSString</span> *name = [rs stringForColumn:<span class="string">@"name"</span>];</span><br><span class="line">  <span class="keyword">int</span> age = [rs intForColumn:<span class="string">@"age"</span>];</span><br><span class="line">  <span class="keyword">double</span> score = [rs doubleForColumn:<span class="string">@"score"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>FMDatabaseQueue</li></ul><p>注意：  </p><blockquote><p>FMDatabase这个类是线程不安全的，如果在多个线程中同时使用一个<br>FMDatabase实例，会造成数据混乱等问题<br>为了保证线程安全，FMDB提供方便快捷的FMDatabaseQueue<br>FMDatabaseQueue的创建<br>FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:path];</p></blockquote><p>简单使用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[queue inDatabase:^(FMDatabase *db) &#123; </span><br><span class="line">  [db executeUpdate:<span class="string">@"INSERT INTO t_student(name) VALUES (?)"</span>, <span class="string">@"Jack"</span>];</span><br><span class="line">  [db executeUpdate:<span class="string">@"INSERT INTO t_student(name) VALUES (?)"</span>, <span class="string">@"Rose"</span>];</span><br><span class="line">  [db executeUpdate:<span class="string">@"INSERT INTO t_student(name) VALUES (?)"</span>, <span class="string">@"Jim"</span>];</span><br><span class="line">  FMResultSet *rs = [db executeQuery:<span class="string">@"select * from t_student"</span>];</span><br><span class="line">  <span class="keyword">while</span> ([rs next]) &#123;</span><br><span class="line">    <span class="comment">// …</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>使用事务</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[queue inTransaction:^(FMDatabase *db, <span class="built_in">BOOL</span> *rollback) &#123;</span><br><span class="line">  [db executeUpdate:<span class="string">@"INSERT INTO t_student(name) VALUES (?)"</span>, <span class="string">@"Jack"</span>];</span><br><span class="line">  [db executeUpdate:<span class="string">@"INSERT INTO t_student(name) VALUES (?)"</span>, <span class="string">@"Rose"</span>];</span><br><span class="line">  [db executeUpdate:<span class="string">@"INSERT INTO t_student(name) VALUES (?)"</span>, <span class="string">@"Jim"</span>];</span><br><span class="line">  FMResultSet *rs = [db executeQuery:<span class="string">@"select * from t_student"</span>];</span><br><span class="line">  <span class="keyword">while</span> ([rs next]) &#123;</span><br><span class="line">    <span class="comment">// …</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="三、数据库迁移"><a href="#三、数据库迁移" class="headerlink" title="三、数据库迁移"></a>三、数据库迁移</h3><p>使用FMDB与FMDBMigrationManager结合 进行数据库版本的升级  </p><p>具体可以查看下面博客<br>iOS的数据库升级FMDBMigrationManager:<a href="https://www.jianshu.com/p/66bc680c4360" target="_blank" rel="noopener">https://www.jianshu.com/p/66bc680c4360</a><br>iOS 使用FMDB与FMDBMigrationManager结合 进行数据库版本的升级:<a href="https://blog.csdn.net/u014305730/article/details/82385126" target="_blank" rel="noopener">https://blog.csdn.net/u014305730/article/details/82385126</a>  </p><h3 id="四、数据库加密"><a href="#四、数据库加密" class="headerlink" title="四、数据库加密"></a>四、数据库加密</h3><p>数据库加密一般有两种方式</p><p>1、对所有数据进行加密  </p><p>2、对数据库文件加密</p><p>对比以上两种方式，第一种方式的常见做法是是将要存储的内容先加密然后存到数据库中，使用的时候将数据库解密，但是这样会消耗很多时间，大部分性能消耗在数据的加解密上，同时，第二种方式，SQLite本身支持加密功能(免费版的不支持) ，SQLCipher是一个开源的SQLite加密扩展，支持对db文件进行256位的AES加密，通常我们会用FMDB这个工具库，FMDB对原生的SQLite进行了封装，提供了面向对象的方式对数据库操作，同时FMDB 也提供了对 SQLCipher 的支持。（在github上集成fmdb上可以看到pod ’fmdb/sqlCipher‘）  </p><p>FMDB数据库加密:<a href="https://www.jianshu.com/p/0c38bf93dcc0" target="_blank" rel="noopener">https://www.jianshu.com/p/0c38bf93dcc0</a></p><h3 id="五、示例代码"><a href="#五、示例代码" class="headerlink" title="五、示例代码"></a>五、示例代码</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)openDB &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *path = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).lastObject stringByAppendingPathComponent:<span class="string">@"database.sqlite"</span>];</span><br><span class="line">    FMDatabase *db = [FMDatabase databaseWithPath:path];</span><br><span class="line">    _db = db;</span><br><span class="line">    <span class="keyword">if</span> ([db open]) &#123;</span><br><span class="line">        <span class="built_in">BOOL</span> result = [db executeUpdate:<span class="string">@"CREATE TABLE IF NOT EXISTS t_student (id integer PRIMARY KEY AUTOINCREMENT, name text NOT NULL, age integer NOT NULL);"</span>];</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"表创建成功"</span>);</span><br><span class="line">            [db close];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"表创建失败"</span>);</span><br><span class="line">             [db close];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"打开失败"</span>);</span><br><span class="line">         [db close];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)add &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.db open]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.db executeUpdate:<span class="string">@"INSERT INTO t_student (name, age) VALUES (?,?);"</span>, <span class="string">@"tom"</span>, @(arc4random_uniform(<span class="number">40</span>))];</span><br><span class="line">        <span class="comment">//    [self.db executeUpdate:@"INSERT INTO t_student (name, age) VALUES (?,?);" withArgumentsInArray:@[@"tom",@(arc4random_uniform(40))]];</span></span><br><span class="line">        <span class="comment">//    [self.db executeUpdateWithFormat:@"INSERT INTO t_student (name, age) VALUES (%@,%d);", @"tom", @(arc4random_uniform(40))];</span></span><br><span class="line">        [<span class="keyword">self</span>.db close];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)deleteStudent:(<span class="built_in">NSInteger</span>)ID &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.db open]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.db executeUpdate:<span class="string">@"delete from t_student where id = ?;"</span>, @(ID)];</span><br><span class="line">        [<span class="keyword">self</span>.db close];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)update:(Student *)s &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.db open]) &#123;</span><br><span class="line">        s.age = s.age - <span class="number">1</span>;</span><br><span class="line">        [<span class="keyword">self</span>.db executeUpdate:<span class="string">@"update t_student set age = ? where id = ?;"</span>,s.age, s.ID];</span><br><span class="line">        [<span class="keyword">self</span>.db close];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)query &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.db open]) &#123;</span><br><span class="line">        FMResultSet *resultSet = [<span class="keyword">self</span>.db executeQuery:<span class="string">@"SELECT * FROM t_student;"</span>];</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *tmp = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        <span class="keyword">while</span> ([resultSet next]) &#123;</span><br><span class="line">            <span class="keyword">int</span> ID = [resultSet intForColumn:<span class="string">@"id"</span>];</span><br><span class="line">            <span class="built_in">NSString</span> *name = [resultSet stringForColumn:<span class="string">@"name"</span>];</span><br><span class="line">            <span class="keyword">int</span> age = [resultSet intForColumn:<span class="string">@"age"</span>];</span><br><span class="line">            </span><br><span class="line">            Student *s = [[Student alloc]init];</span><br><span class="line">            s.ID = ID;</span><br><span class="line">            s.name = name;</span><br><span class="line">            s.age = age;</span><br><span class="line">            </span><br><span class="line">            [tmp addObject:s];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.students = tmp;</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span>.db close];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>iOS开发数据库篇—FMDB简单介绍:<a href="https://www.cnblogs.com/wendingding/p/3871848.html" target="_blank" rel="noopener">https://www.cnblogs.com/wendingding/p/3871848.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、基本介绍&quot;&gt;&lt;a href=&quot;#一、基本介绍&quot; class=&quot;headerlink&quot; title=&quot;一、基本介绍&quot;&gt;&lt;/a&gt;一、基本介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;什么是FMDB  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;– FMDB是iOS平台的SQLite数据库框架
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>CoreData使用分析</title>
    <link href="http://yoursite.com/2020/05/12/CoreData%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/05/12/CoreData%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/</id>
    <published>2020-05-12T05:55:59.000Z</published>
    <updated>2020-05-12T05:57:15.347Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、基本介绍"><a href="#一、基本介绍" class="headerlink" title="一、基本介绍"></a>一、基本介绍</h3><ul><li><p>什么是CoreData<br>CoreData是Apple官方为iOS提供的一个数据持久化方案，其本质是一个通过封装底层数据操作，让程序员以面向对象的方式存储和管理数据的ORM框架（Object-Relational Mapping：对象-关系映射，简称ORM）。虽然底层支持SQLite、二进制数据、xml等多种文件存储，但是主要还是用来操作SQLite数据库。<br>程序员不需要学习或者使用SQL语句，只需要使用CoreData框架提供的对象和接口以及图形化工具，即可完成SQLite数据库的创建、表关系、增删改查等一系列操作，在一定程度上降低了程序员的学习成本并增加了代码的统一性和可阅读性。</p></li><li><p>CoreData主要包含以下几个类<br>– <strong>NSManagedObjectModel</strong>：托管对象模型，映射实体类和数据库数据的关系，本质是一个XML文件，后面简称MOM<br>– <strong>NSManagedObject</strong>：托管对象，对应数据库数据的实体，后面简称MO<br>– <strong>NSManagedObjectContext</strong>：托管对象上下文，管理托管对象，后面简称MOC<br>– <strong>NSPersistentStoreCoordinator</strong>：持久化存储调度器，用来处理磁盘持久化数据和实体类对象的相互转化，后面简称PSC<br>– <strong>NSPersistentStore</strong>：持久化存储器，负责磁盘持久化数据存取，后面简称PS<br>– <strong>NSEntityDescription</strong>：用来描述实体<br>– <strong>NSFetchRequest</strong>：操作请求</p></li><li><p>CoreData的总体框架如下图<br><img src="images/db/db1.jpg" alt=""><br>在上层通过MOC操作对应的托管对象，然后MOC会将操作传递给PSC，PSC通过托管对象模型中的映射关系，再将托管对象的操作转化为对底层数据的操作，进行数据存取操作。</p></li></ul><h3 id="二、简单创建流程"><a href="#二、简单创建流程" class="headerlink" title="二、简单创建流程"></a>二、简单创建流程</h3><ol><li><p>模型文件操作<br>1.1 创建模型文件，后缀为<code>.xcdatamodeld</code>。创建模型文件之后，可以在内部进行添加实体等操作（用于表示数据库文件的数据结构）。<br>1.2 添加实体（表示数据库文件的表结构），添加实体后需要通过实体来创建托管对象类文件。<br>1.3 天剑属性并设置类型，可以在属性的右侧面板中设置默认值等选项。（每种数据类型设置的选项是不同的）。<br>1.4 创建请求模板，设置配置模板等。<br>1.5 根据指定实体，创建托管对象类文件（基于<code>NSManagedObject</code>）.  </p></li><li><p>实例化上下文对象<br>2.1 创建托管上下文（<code>NSManagedObjectContext</code>）。<br>2.2 创建托管对象模型（<code>NSManagedObjectModel</code>）。<br>2.3 根据托管对象模型，创建持久化存储协调器（<code>NSPersistentStoreCoordinator</code>）。<br>2.4 关联并创建本地数据库文件，并返回持久化存储持对象（<code>NSPersistentStore</code>）。<br>2.5 将持久化存储协调器赋值给托管对象上下文，完成基本创建。</p></li><li><p>示例<br>下面是根据Company模型文件，创建了一个主队列并发类型的MOC  </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建上下文对象，并发队列设置为主队列</span></span><br><span class="line"><span class="built_in">NSManagedObjectContext</span> *context = [[<span class="built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="built_in">NSMainQueueConcurrencyType</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建托管对象模型，并使用Company.momd路径当做初始化参数</span></span><br><span class="line"><span class="built_in">NSURL</span> *modelPath = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"Company"</span> withExtension:<span class="string">@"momd"</span>];</span><br><span class="line"><span class="built_in">NSManagedObjectModel</span> *model = [[<span class="built_in">NSManagedObjectModel</span> alloc] initWithContentsOfURL:modelPath];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建持久化存储调度器</span></span><br><span class="line"><span class="built_in">NSPersistentStoreCoordinator</span> *coordinator = [[<span class="built_in">NSPersistentStoreCoordinator</span> alloc] initWithManagedObjectModel:model];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并关联SQLite数据库文件，如果已经存在则不会重复创建</span></span><br><span class="line"><span class="built_in">NSString</span> *dataPath = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).lastObject;</span><br><span class="line">dataPath = [dataPath stringByAppendingFormat:<span class="string">@"/%@.sqlite"</span>, <span class="string">@"Company"</span>];</span><br><span class="line">[coordinator addPersistentStoreWithType:<span class="built_in">NSSQLiteStoreType</span> configuration:<span class="literal">nil</span> URL:[<span class="built_in">NSURL</span> fileURLWithPath:dataPath] options:<span class="literal">nil</span> error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文对象设置属性为持久化存储器</span></span><br><span class="line">context.persistentStoreCoordinator = coordinator;</span><br></pre></td></tr></table></figure></li></ol><h3 id="三、基本操作"><a href="#三、基本操作" class="headerlink" title="三、基本操作"></a>三、基本操作</h3><ol><li><p>插入操作</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建托管对象，并指明创建的托管对象所属实体名</span></span><br><span class="line">Employee *emp = [<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="string">@"Employee"</span> inManagedObjectContext:context];</span><br><span class="line">emp.name = <span class="string">@"lxz"</span>;</span><br><span class="line">emp.height = @<span class="number">1.7</span>;</span><br><span class="line">emp.brithday = [<span class="built_in">NSDate</span> date];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过上下文保存对象，并在保存前判断是否有更改</span></span><br><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">if</span> (context.hasChanges) &#123;</span><br><span class="line">    [context save:&amp;error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理</span></span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"CoreData Insert Data Error : %@"</span>, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除操作</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立获取数据的请求对象，指明对Employee实体进行删除操作</span></span><br><span class="line"><span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> fetchRequestWithEntityName:<span class="string">@"Employee"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建谓词对象，过滤出符合要求的对象，也就是要删除的对象</span></span><br><span class="line"><span class="built_in">NSPredicate</span> *predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name = %@"</span>, <span class="string">@"lxz"</span>];</span><br><span class="line">request.predicate = predicate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行获取操作，找到要删除的对象</span></span><br><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSArray</span>&lt;Employee *&gt; *employees = [context executeFetchRequest:request error:&amp;error];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历符合删除要求的对象数组，执行删除操作</span></span><br><span class="line">[employees enumerateObjectsUsingBlock:^(Employee * _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">    [context deleteObject:obj];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存上下文</span></span><br><span class="line"><span class="keyword">if</span> (context.hasChanges) &#123;</span><br><span class="line">    [context save:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理</span></span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"CoreData Delete Data Error : %@"</span>, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改操作</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立获取数据的请求对象，并指明操作的实体为Employee</span></span><br><span class="line"><span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> fetchRequestWithEntityName:<span class="string">@"Employee"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建谓词对象，设置过滤条件</span></span><br><span class="line"><span class="built_in">NSPredicate</span> *predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name = %@"</span>, <span class="string">@"lxz"</span>];</span><br><span class="line">request.predicate = predicate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行获取请求，获取到符合要求的托管对象</span></span><br><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSArray</span>&lt;Employee *&gt; *employees = [context executeFetchRequest:request error:&amp;error];</span><br><span class="line">[employees enumerateObjectsUsingBlock:^(Employee * _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">    obj.height = @<span class="number">3.</span>f;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将上面的修改进行存储</span></span><br><span class="line"><span class="keyword">if</span> (context.hasChanges) &#123;</span><br><span class="line">    [context save:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理</span></span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"CoreData Update Data Error : %@"</span>, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查找操作</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立获取数据的请求对象，指明操作的实体为Employee</span></span><br><span class="line"><span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> fetchRequestWithEntityName:<span class="string">@"Employee"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行获取操作，获取所有Employee托管对象</span></span><br><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSArray</span>&lt;Employee *&gt; *employees = [context executeFetchRequest:request error:&amp;error];</span><br><span class="line">[employees enumerateObjectsUsingBlock:^(Employee * _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Employee Name : %@, Height : %@, Brithday : %@"</span>, obj.name, obj.height, obj.brithday);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理</span></span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"CoreData Ergodic Data Error : %@"</span>, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找操作最简单粗暴，因为是演示代码，所以直接将所有Employee表中的托管对象加载出来。在实际开发中肯定不会这样做，只需要加载需要的数据。后面还会讲到一些更高级的操作，会涉及到获取方面的东西。</p></li></ol><h3 id="四、版本迁移"><a href="#四、版本迁移" class="headerlink" title="四、版本迁移"></a>四、版本迁移</h3><p>几种版本迁移方案，在迁移之前都需要对原有的模型文件创建新的版本</p><p><strong>选中需要做迁移的模型文件 -&gt; 点击菜单栏Editor -&gt; Add Model Versioon -&gt; 选择基于哪个版本的的模型文件（一般都是选择目前最新的版本），新建模型文件完成。</strong></p><p>对于新版本的模型文件的命名，一般会拿当前工程版本号当后缀，这样在模型文件比较多时，可以很容易将模型文件版本和工程版本对应起来。</p><ol><li><p>轻量级迁移 （修改了model文件，不过不做迁移，在使用数据操作就会闪退，除非删掉沙盒里的sqlite）</p></li><li><p>Mapping Model迁移方案</p></li><li><p>渐进式迁移</p></li><li><p>更复杂的迁移需求</p></li></ol><h3 id="五、多线程"><a href="#五、多线程" class="headerlink" title="五、多线程"></a>五、多线程</h3><p>在业务比较复杂的情况下，需要进行大量数据处理，并且还需要涉及到UI的操作。对于这种复杂需求，如果都放在主队列中，对性能和界面流畅度都会有很大的影响，导致用户体验非常差，降低屏幕FPS。对于这种情况，可以采取多个MOC配合的方式。</p><p><strong>Core Data多线程操作的基本原则</strong><br>不允许跨线程访问MOC： 在某一个MOC上的CRUD操作只能在它的操作线程上进行<br>不允许跨线程访问MO：对MO的操作只能在它所属的MOC的操作线程上进行。需要注意的是，访问一个FRC的fetchedObjects数组也只能在FRC所属的MOC的操作线程上进行</p><p><strong>iOS5之前使用多个MOC</strong></p><p>在iOS5之前实现MOC的多线程，可以创建多个MOC，多个MOC使用同一个PSC，并让多个MOC实现数据同步。通过这种方式不用担心PSC在调用过程中的线程问题，MOC在使用PSC进行save操作时，会对PSC进行加锁，等当前加锁的MOC执行完操作之后，其他MOC才能继续执行操作。</p><p>每一个PSC都对应着一个持久化存储区，PSC知道存储区中数据存储的数据结构，而MOC需要使用这个PSC进行save操作的实现。<br>这样做有一个问题，当一个MOC发生改变并持久化到本地时，系统并不会将其他MOC缓存在内存中的NSManagedObject对象改变。所以这就需要我们在MOC发生改变时，将其他MOC数据更新。</p><p>根据上面的解释，在下面例子中创建了一个主队列的mainMOC，主要用于UI操作。一个私有队列的backgroundMOC，用于除UI之外的耗时操作，两个MOC使用的同一个PSC。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取PSC实例对象</span></span><br><span class="line">- (<span class="built_in">NSPersistentStoreCoordinator</span> *)persistentStoreCoordinator &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建托管对象模型，并指明加载Company模型文件</span></span><br><span class="line">    <span class="built_in">NSURL</span> *modelPath = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"Company"</span> withExtension:<span class="string">@"momd"</span>];</span><br><span class="line">    <span class="built_in">NSManagedObjectModel</span> *model = [[<span class="built_in">NSManagedObjectModel</span> alloc] initWithContentsOfURL:modelPath];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建PSC对象，并将托管对象模型当做参数传入，其他MOC都是用这一个PSC。</span></span><br><span class="line">    <span class="built_in">NSPersistentStoreCoordinator</span> *PSC = [[<span class="built_in">NSPersistentStoreCoordinator</span> alloc] initWithManagedObjectModel:model];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据指定的路径，创建并关联本地数据库</span></span><br><span class="line">    <span class="built_in">NSString</span> *dataPath = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>).lastObject;</span><br><span class="line">    dataPath = [dataPath stringByAppendingFormat:<span class="string">@"/%@.sqlite"</span>, <span class="string">@"Company"</span>];</span><br><span class="line">    [PSC addPersistentStoreWithType:<span class="built_in">NSSQLiteStoreType</span> configuration:<span class="literal">nil</span> URL:[<span class="built_in">NSURL</span> fileURLWithPath:dataPath] options:<span class="literal">nil</span> error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> PSC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化用于本地存储的所有MOC</span></span><br><span class="line">- (<span class="keyword">void</span>)createManagedObjectContext &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建PSC实例对象，其他MOC都用这一个PSC。</span></span><br><span class="line">    <span class="built_in">NSPersistentStoreCoordinator</span> *PSC = <span class="keyword">self</span>.persistentStoreCoordinator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主队列MOC，用于执行UI操作</span></span><br><span class="line">    <span class="built_in">NSManagedObjectContext</span> *mainMOC = [[<span class="built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="built_in">NSMainQueueConcurrencyType</span>];</span><br><span class="line">    mainMOC.persistentStoreCoordinator = PSC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建私有队列MOC，用于执行其他耗时操作</span></span><br><span class="line">    <span class="built_in">NSManagedObjectContext</span> *backgroundMOC = [[<span class="built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="built_in">NSPrivateQueueConcurrencyType</span>];</span><br><span class="line">    backgroundMOC.persistentStoreCoordinator = PSC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过监听NSManagedObjectContextDidSaveNotification通知，来获取所有MOC的改变消息</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(contextChanged:) name:<span class="built_in">NSManagedObjectContextDidSaveNotification</span> object:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MOC改变后的通知回调</span></span><br><span class="line">- (<span class="keyword">void</span>)contextChanged:(<span class="built_in">NSNotification</span> *)noti &#123;</span><br><span class="line">    <span class="built_in">NSManagedObjectContext</span> *MOC = noti.object;</span><br><span class="line">    <span class="comment">// 这里需要做判断操作，判断当前改变的MOC是否我们将要做同步的MOC，如果就是当前MOC自己做的改变，那就不需要再同步自己了。</span></span><br><span class="line">    <span class="comment">// 由于项目中可能存在多个PSC，所以下面还需要判断PSC是否当前操作的PSC，如果不是当前PSC则不需要同步，不要去同步其他本地存储的数据。</span></span><br><span class="line">    [MOC performBlock:^&#123;</span><br><span class="line">        <span class="comment">// 直接调用系统提供的同步API，系统内部会完成同步的实现细节。</span></span><br><span class="line">        [MOC mergeChangesFromContextDidSaveNotification:noti];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的Demo中，创建了一个PSC，并将其他MOC都关联到这个PSC上，这样所有的MOC执行本地持久化相关的操作时，都是通过同一个PSC进行操作的。并在下面添加了一个通知，这个通知是监听所有MOC执行save操作后的通知，并在通知的回调方法中进行数据的合并。</p><p><strong>iOS5之后使用多个MOC</strong></p><p>在iOS5之后，MOC可以设置parentContext，一个parentContext可以拥有多个ChildContext。在ChildContext执行save操作后，会将操作push到parentContext，由parentContext去完成真正的save操作，而ChildContext所有的改变都会被parentContext所知晓，这解决了之前MOC手动同步数据的问题。</p><p>需要注意的是，在ChildContext调用save方法之后，此时并没有将数据写入存储区，还需要调用parentContext的save方法。因为ChildContext并不拥有PSC，ChildContext也不需要设置PSC，所以需要parentContext调用PSC来执行真正的save操作。也就是只有拥有PSC的MOC执行save操作后，才是真正的执行了写入存储区的操作。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)createManagedObjectContext &#123;</span><br><span class="line">    <span class="comment">// 创建PSC实例对象，还是用上面Demo的实例化代码</span></span><br><span class="line">    <span class="built_in">NSPersistentStoreCoordinator</span> *PSC = <span class="keyword">self</span>.persistentStoreCoordinator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建主队列MOC，用于执行UI操作</span></span><br><span class="line">    <span class="built_in">NSManagedObjectContext</span> *mainMOC = [[<span class="built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="built_in">NSMainQueueConcurrencyType</span>];</span><br><span class="line">    mainMOC.persistentStoreCoordinator = PSC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建私有队列MOC，用于执行其他耗时操作，backgroundMOC并不需要设置PSC</span></span><br><span class="line">    <span class="built_in">NSManagedObjectContext</span> *backgroundMOC = [[<span class="built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="built_in">NSPrivateQueueConcurrencyType</span>];</span><br><span class="line">    backgroundMOC.parentContext = mainMOC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有队列的MOC和主队列的MOC，在执行save操作时，都应该调用performBlock:方法，在自己的队列中执行save操作。</span></span><br><span class="line">    <span class="comment">// 私有队列的MOC执行完自己的save操作后，还调用了主队列MOC的save方法，来完成真正的持久化操作，否则不能持久化到本地</span></span><br><span class="line">    [backgroundMOC performBlock:^&#123;</span><br><span class="line">        [backgroundMOC save:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">        [mainMOC performBlock:^&#123;</span><br><span class="line">            [mainMOC save:<span class="literal">nil</span>];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子中创建一个主队列的mainMOC，来完成UI相关的操作。创建私有队列的backgroundMOC，处理复杂逻辑以及数据处理操作，在实际开发中可以根据需求创建多个backgroundMOC。需要注意的是，在backgroundMOC执行完save方法后，又在mainMOC中执行了一次save方法，这步是很重要的。</p><h3 id="多个MOC面临的多线程问题"><a href="#多个MOC面临的多线程问题" class="headerlink" title="多个MOC面临的多线程问题"></a>多个MOC面临的多线程问题</h3><p><strong>1.线程安全</strong><br>无论是MOC还是托管对象，都不应该在其他MOC的线程中执行操作，这两个API都不是线程安全的。但MOC可以在其他MOC线程中调用performBlock:方法，切换到自己的线程执行操作。</p><p>如果其他MOC想要拿到托管对象，并在自己的队列中使用托管对象，这是不允许的，托管对象是不能直接传递到其他MOC的线程的。但是可以通过获取NSManagedObject的NSManagedObjectID对象，在其他MOC中通过NSManagedObjectID对象，从持久化存储区中获取NSManagedObject对象，这样就是允许的。NSManagedObjectID是线程安全，并且可以跨线程使用的。</p><p>可以通过MOC获取NSManagedObjectID对应的NSManagedObject对象，例如下面几个MOC的API。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSManagedObject</span> *object = [context objectRegisteredForID:objectID];</span><br><span class="line"><span class="built_in">NSManagedObject</span> *object = [context objectWithID:objectID];</span><br></pre></td></tr></table></figure><p>通过NSManagedObject对象的objectID属性，获取NSManagedObjectID类型的objectID对象。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSManagedObjectID</span> *objectID = object.objectID;</span><br></pre></td></tr></table></figure><p><strong>2.MOC同步时机</strong><br>设置MOC的parentContext属性之后，parent对于child的改变是知道的，但是child对于parent的改变是不知道的。苹果这样设计，应该是为了更好的数据同步。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Employee *emp = [<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:<span class="string">@"Employee"</span> inManagedObjectContext:backgroundMOC];</span><br><span class="line">emp.name = <span class="string">@"lxz"</span>;</span><br><span class="line">emp.brithday = [<span class="built_in">NSDate</span> date];</span><br><span class="line">emp.height = @<span class="number">1.7</span>f;</span><br><span class="line"></span><br><span class="line">[backgroundMOC performBlock:^&#123;</span><br><span class="line">    [backgroundMOC save:<span class="literal">nil</span>];</span><br><span class="line">    [mainMOC performBlock:^&#123;</span><br><span class="line">        [mainMOC save:<span class="literal">nil</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>在上面这段代码中，mainMOC是backgroundMOC的parentContext。在backgroundMOC执行save方法前，backgroundMOC和mainMOC都不能获取到Employee的数据，在backgroundMOC执行完save方法后，自身上下文发生改变的同时，也将改变push到mainMOC中，mainMOC也具有了Employee对象。</p><p>所以在backgroundMOC的save方法执行时，是对内存中的上下文做了改变，当拥有PSC的mainMOC执行save方法后，是对本地存储区做了改变。</p><h3 id="参看链接"><a href="#参看链接" class="headerlink" title="参看链接"></a>参看链接</h3><p>Core Data 概述:(相关CoreData系列文章)<a href="https://objccn.io/issue-4-1/" target="_blank" rel="noopener">https://objccn.io/issue-4-1/</a><br>认识CoreData - 初识CoreData(写了CoreData系列文章，都可以看看)：<a href="https://www.jianshu.com/p/c0e12a897971" target="_blank" rel="noopener">https://www.jianshu.com/p/c0e12a897971</a></p><p>Core Data三层设计方案：<a href="https://github.com/ChenYongJunM/CoreDataMultithread" target="_blank" rel="noopener">https://github.com/ChenYongJunM/CoreDataMultithread</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、基本介绍&quot;&gt;&lt;a href=&quot;#一、基本介绍&quot; class=&quot;headerlink&quot; title=&quot;一、基本介绍&quot;&gt;&lt;/a&gt;一、基本介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;什么是CoreData&lt;br&gt;CoreData是Apple官方为iOS提供的一个数据持久化
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>App启动过程</title>
    <link href="http://yoursite.com/2020/05/12/App%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/05/12/App%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</id>
    <published>2020-05-12T05:54:46.000Z</published>
    <updated>2020-05-22T10:24:30.730Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、“冷启动”与“热启动”"><a href="#一、“冷启动”与“热启动”" class="headerlink" title="一、“冷启动”与“热启动”"></a>一、“冷启动”与“热启动”</h4><p>首先，我们先来区分两个启动的概念。</p><ul><li>冷启动：<br> <code>App</code>点击启动前，此时<code>App</code>的进程还不在系统里。<br> 需要系统新创建一个进程分配给<code>App</code>。（这是一次完整的<code>App</code>启动过程）</li><li>热启动：<br> <code>App</code>在冷启动后用户将<code>App</code>退回后台，此时<code>App</code>的进程还在系统里。<br> 用户重新返回<code>App</code>的过程。（热启动做的事较少）</li></ul><p>主要区别：</p><table><thead><tr><th>名称</th><th>区别</th></tr></thead><tbody><tr><td>冷启动</td><td>启动时，App的进程<strong>不在</strong>系统里，<strong>需要</strong>开启新进程。</td></tr><tr><td>热启动</td><td>启动时，App的进程<strong>还在</strong>系统里，<strong>不需要</strong>开启新进程。</td></tr></tbody></table><h4 id="二、App的完整启动流程（冷启动流程）"><a href="#二、App的完整启动流程（冷启动流程）" class="headerlink" title="二、App的完整启动流程（冷启动流程）"></a>二、App的完整启动流程（冷启动流程）</h4><p>主要分为三个阶段：</p><ol><li><strong><code>main()</code> 函数执行前（pre-main阶段）</strong></li><li><strong><code>main()</code> 函数执行后（从<code>main</code>函数执行，到设置<code>self.window.rootViewController</code>执行完成）</strong></li><li><strong>首屏渲染完成后（从<code>self.window.rootViewController</code>执行完成到<code>didFinishLaunchWithOptions</code>方法作用域结束）</strong></li></ol><hr><h5 id="（1）main函数执行前，系统会做的事："><a href="#（1）main函数执行前，系统会做的事：" class="headerlink" title="（1）main函数执行前，系统会做的事："></a>（1）main函数执行前，系统会做的事：</h5><ul><li>加载可执行文件。（<code>App</code>里的所有<code>.o</code>文件）</li><li>加载动态链接库，进行<code>rebase</code>指针调整和<code>bind</code>符号绑定。</li><li><code>ObjC</code>的<code>runtime</code>初始化。 包括：<code>ObjC</code>相关<code>Class</code>的注册、<code>category</code>注册、<code>selector</code>唯一性检查等。</li><li>初始化。 包括：执行<code>+load()</code>方法、用<code>attribute((constructor))</code>修饰的函数的调用、创建<code>C++</code>静态全局变量等。</li></ul><p><img src="1.jpg" alt=""></p><blockquote><p>简单来说，<br> App启动后，首先，系统内核（<a href="https://baike.so.com/doc/6792525-7009150.html" target="_blank" rel="noopener">Kernel</a>）创建一个进程。<br> 其次，加载可执行文件。（可执行文件是指<a href="http://www.cocoachina.com/articles/10988" target="_blank" rel="noopener">Mach-O</a>格式的文件，也就是App中所有.o文件的集合体）这时，能获取到dyld（dyld是苹果的动态链接器）的路径。<br> 然后，加载dyld，主要分为4步：<br> 1 . <strong>load dylibs</strong>：这一阶段dyld会分析应用依赖的<code>dylib</code>，找到其<code>mach-o</code>文件，打开和读取这些文件并验证其有效性，接着会找到代码签名注册到内核，最后对<code>dylib</code>的每一个<code>segment</code>调用<a href="https://baike.so.com/doc/6784320-7000923.html" target="_blank" rel="noopener">mmap()</a>。<br> 2 . <strong>rebase/bind</strong>：进行<code>rebase</code>指针调整和<code>bind</code>符号绑定。<br> 3 . <strong>ObjC setup</strong>：runtime运行时初始化。包括<code>ObjC</code>相关<code>Class</code>的注册、<code>category</code>注册、<code>selector</code>唯一性检查等。<br> 4 . <strong>Initializers</strong>：调用每个<code>ObjC</code>类与分类的<code>+load</code>方法，调用<code>attribute((constructor))</code>修饰的函数、创建<code>C++</code>静态全局变量。</p></blockquote><hr><h5 id="（2）main函数执行后："><a href="#（2）main函数执行后：" class="headerlink" title="（2）main函数执行后："></a>（2）main函数执行后：</h5><p>main函数执行后的阶段，指的是：从 <code>main</code> 函数执行开始，到 <code>appDelegate</code> 的 <code>didFinishLaunchingWithOptions</code>方法里首屏渲染相关方法执行完成。 即，从<code>main</code>函数执行到设置<code>self.window.rootViewController</code>执行完成的阶段。</p><ul><li>首屏初始化所需配置文件的读写操作；</li><li>首屏列表大数据的读取；</li><li>首屏渲染的大量计算；</li></ul><p><img src="2.jpg" alt=""></p><h5 id="（3）首屏渲染完成后："><a href="#（3）首屏渲染完成后：" class="headerlink" title="（3）首屏渲染完成后："></a>（3）首屏渲染完成后：</h5><p>首屏渲染完成后的阶段，指的是：<code>didFinishLaunchingWithOptions</code>方法作用域 内执行首屏渲染后的所有方法执行。 即从设置<code>self.window.rootViewController</code>到<code>didFinishLaunchWithOptions</code>方法作用域结束。</p><p>这个阶段，首屏已经渲染完成。</p><p>需要做的事：</p><ul><li>初始化一些首屏展示不需要的功能。</li><li>优化主线程，先处理会卡住主线程的方法，不能影响到用户的后续操作。</li></ul><hr><h4 id="三、具体优化思路"><a href="#三、具体优化思路" class="headerlink" title="三、具体优化思路"></a>三、具体优化思路</h4><p>用户能感知到的启动时长主要是在 <strong>“main函数执行前”</strong> 、<strong>“main函数执行后到首屏渲染完成”</strong>的阶段。</p><blockquote><p>main函数执行前，优化思路如下：</p></blockquote><h6 id="（1）减少使用-load-方法"><a href="#（1）减少使用-load-方法" class="headerlink" title="（1）减少使用 +load() 方法"></a>（1）减少使用 <code>+load()</code> 方法</h6><ul><li>方案一：如果可能的话，将<code>+load</code>中的内容，放到渲染完成后做。</li><li>方案二：使用<code>+initialize()</code>的方法代替<code>+load()</code>，注意把逻辑移动到<code>+initialize()</code>时，要注意避免<code>+initialize()</code>的重复调用问题，可以使用<code>dispatch_once()</code>让逻辑只执行一次。</li></ul><blockquote><p>小知识点：<code>+load()</code>与<code>+initialize()</code>两者的区别?<br> <strong><code>+load()</code>方法会在main()函数调用前就调用，而<code>+initialize()</code>是在类第一次使用时才会调用。</strong><br> <code>+load</code>方法的调用优先级: 父类 &gt; 子类 &gt; 分类，并且不会被覆盖，均会调用。<br> <code>+load</code>方法是在main() 函数之前调用，所有的类文件都会加载，包括分类也会加载。 <code>+initialize</code>方法的调用优先级：分类 &gt; 子类，父类 &gt; 子类。（父类的分类重写了<code>+initialize</code>方法会覆盖父类的<code>+initialize</code>方法）</p></blockquote><h6 id="（2）合并多个动态库"><a href="#（2）合并多个动态库" class="headerlink" title="（2）合并多个动态库"></a>（2）合并多个动态库</h6><p>苹果公司建议使用更少的动态库，并且建议在使用动态库的数量较多时，尽量将多个动态库进行合并。数量上，苹果公司最多可以支持<code>6</code>个非系统动态库合并为一个。</p><h6 id="（3）优化类、方法、全局变量"><a href="#（3）优化类、方法、全局变量" class="headerlink" title="（3）优化类、方法、全局变量"></a>（3）优化类、方法、全局变量</h6><p>减少加载启动后不会去使用的类或方法；少用C++全局变量；</p><blockquote><p>main函数执行后，优化方案如下：</p></blockquote><h6 id="（4）优化首屏渲染前的功能初始化"><a href="#（4）优化首屏渲染前的功能初始化" class="headerlink" title="（4）优化首屏渲染前的功能初始化"></a>（4）优化首屏渲染前的功能初始化</h6><p>main函数执行后到首屏渲染完成前，只处理<strong>首屏渲染</strong>相关业务。 首屏渲染外的<strong>其他功能</strong>放到首屏渲染完成后去初始化。</p><h6 id="（5）优化主线程耗时操作，防止屏幕卡顿。"><a href="#（5）优化主线程耗时操作，防止屏幕卡顿。" class="headerlink" title="（5）优化主线程耗时操作，防止屏幕卡顿。"></a>（5）优化主线程耗时操作，防止屏幕卡顿。</h6><p>首先检查首屏渲染前，主线程上的耗时操作。将耗时操作滞后或异步处理。 通常的耗时操作有：网络加载、编辑、存储图片和文件等资源。 针对耗时操作做相对应的优化即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、“冷启动”与“热启动”&quot;&gt;&lt;a href=&quot;#一、“冷启动”与“热启动”&quot; class=&quot;headerlink&quot; title=&quot;一、“冷启动”与“热启动”&quot;&gt;&lt;/a&gt;一、“冷启动”与“热启动”&lt;/h4&gt;&lt;p&gt;首先，我们先来区分两个启动的概念。&lt;/p&gt;
&lt;ul&gt;
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>load和initialize方法的区别</title>
    <link href="http://yoursite.com/2020/05/12/load%E5%92%8Cinitialize%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/05/12/load%E5%92%8Cinitialize%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-05-12T01:59:04.000Z</published>
    <updated>2020-05-12T06:02:19.638Z</updated>
    
    <content type="html"><![CDATA[<h4 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h4><p>1、load是根据函数地址直接调用</p><p>2、initialize是通过objc_msgSeng调用</p><h4 id="调用时刻"><a href="#调用时刻" class="headerlink" title="调用时刻"></a>调用时刻</h4><p>1、load是runtime加载类、分类的时候调用(只会调用一次)</p><p>2、initialize是类第一次接收到消息的时候调用, 每一个类只会initialize一次(如果子类没有实现initialize方法, 会调用父类的initialize方法, 所以父类的initialize方法可能会调用多次)</p><h4 id="load和initializee的调用顺序"><a href="#load和initializee的调用顺序" class="headerlink" title="load和initializee的调用顺序"></a>load和initializee的调用顺序</h4><p><strong>load</strong></p><p>1、先调用类的load</p><ul><li><p>先编译的类, 优先调用load（先编译，先调用）</p></li><li><p>调用子类的load之前, 会先调用父类的load</p></li></ul><p>2、再调用分类的load</p><ul><li>先编译的分类, 优先调用load（先编译，先调用）</li></ul><p><strong>initialize</strong></p><p>先调用父类的+initialize，再调用子类的+initialize。（先初始化父类，再初始化子类，每个类只会初始化1次）<br>如果分类实现了+initialize，会覆盖原有类的+initialize</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li><p>+initialize和+load的最大区别是</p><ul><li><p>initialize是通过objc_msgSeng调用，load是根据函数地址直接调用；</p></li><li><p>如果子类没有实现initialize方法, 会调用父类的initialize方法, 所以父类的initialize方法可能会调用多次</p></li><li><p>如果分类实现了+initialize，会覆盖原有类的+initialize</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;调用方式&quot;&gt;&lt;a href=&quot;#调用方式&quot; class=&quot;headerlink&quot; title=&quot;调用方式&quot;&gt;&lt;/a&gt;调用方式&lt;/h4&gt;&lt;p&gt;1、load是根据函数地址直接调用&lt;/p&gt;
&lt;p&gt;2、initialize是通过objc_msgSeng调用&lt;/p&gt;
&lt;h4
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS面试题收录（三）</title>
    <link href="http://yoursite.com/2020/05/08/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E5%BD%95%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2020/05/08/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E5%BD%95%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2020-05-08T14:21:26.000Z</published>
    <updated>2020-05-11T01:47:05.483Z</updated>
    
    <content type="html"><![CDATA[<p>主题：高级问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主题：高级问题&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS高级必备知识</title>
    <link href="http://yoursite.com/2020/05/08/iOS%E9%AB%98%E7%BA%A7%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2020/05/08/iOS%E9%AB%98%E7%BA%A7%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86/</id>
    <published>2020-05-08T13:21:01.000Z</published>
    <updated>2020-05-11T01:47:05.483Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、UI视图"><a href="#一、UI视图" class="headerlink" title="一、UI视图"></a>一、UI视图</h3><p>1.1 、事件传递机制</p><p>1.2 、UI绘制原理</p><p>1.3 、异步绘制原理</p><p>1.4 、流失页面的性能优化</p><p>1.5 、离屏渲染</p><h3 id="二、OC语言"><a href="#二、OC语言" class="headerlink" title="二、OC语言"></a>二、OC语言</h3><p>2.1 、KVO</p><p>2.2、 KVC</p><p>2.3、分类</p><p>2.4、 关联对象</p><h3 id="三、Runtime"><a href="#三、Runtime" class="headerlink" title="三、Runtime"></a>三、Runtime</h3><p>3.1、 对象、类、元祖对象</p><p>3.2、 消息传递机制</p><p>3.3、消息转发流程</p><p>3.4、Method-Swizzing</p><h3 id="四、内存"><a href="#四、内存" class="headerlink" title="四、内存"></a>四、内存</h3><p>4.1、 引用计数表</p><p>4.2、 弱引用表</p><p>4.3、 ARC，MRC</p><p>4.4、 循环引用</p><p>4.5、 内存管理</p><h3 id="五、Block"><a href="#五、Block" class="headerlink" title="五、Block"></a>五、Block</h3><p>5.1、 Block本质</p><p>5.2、 截获变量特性</p><p>5.3、 内存管理</p><p>5.4、 循环应用</p><h3 id="六、多线程"><a href="#六、多线程" class="headerlink" title="六、多线程"></a>六、多线程</h3><p>6.1、 GCD，NSoperation</p><p>6.2、 资源共享</p><p>6.3、 线程同步</p><p>6.4、 SpinLock</p><h3 id="七、RunLoop"><a href="#七、RunLoop" class="headerlink" title="七、RunLoop"></a>七、RunLoop</h3><p>7.1、 事件循环</p><p>7.2、 常驻线程</p><h3 id="八、网络"><a href="#八、网络" class="headerlink" title="八、网络"></a>八、网络</h3><p>8.1、 HTTPS</p><p>8.2、 对称加密算法</p><p>8.3、 非对称加密算法</p><p>8.4、 DNS解析</p><p>8.5 HTTP，TCP</p><h3 id="九、设计模式"><a href="#九、设计模式" class="headerlink" title="九、设计模式"></a>九、设计模式</h3><p>9.1、 桥接，适配器，命令</p><p>9.2、 责任链，单例</p><p>9.3、 六大设计原则</p><h3 id="十、架构-框架"><a href="#十、架构-框架" class="headerlink" title="十、架构/框架"></a>十、架构/框架</h3><p>10.1、 MVVM，时长统计框架</p><p>10.2、 图片缓存框架</p><p>10.3、 PV量级10亿业务架构</p><h3 id="十一、算法"><a href="#十一、算法" class="headerlink" title="十一、算法"></a>十一、算法</h3><p>11.1、 字符串反转</p><p>11.2、 单链表反转</p><p>11.3、 有序数组递归</p><p>11.4、 无序数组找中位</p><h3 id="十二、第三方库"><a href="#十二、第三方库" class="headerlink" title="十二、第三方库"></a>十二、第三方库</h3><p>12.1、 AFNETworking<br><strong>…</strong></p><h3 id="十三、跨平台-最少会其一"><a href="#十三、跨平台-最少会其一" class="headerlink" title="十三、跨平台(最少会其一)"></a>十三、跨平台(最少会其一)</h3><p>13.1、 RN</p><p>13.2、 Flutter</p><p>13.3、 Weex</p><h3 id="十四、加分项（不会也没事，会就更好）"><a href="#十四、加分项（不会也没事，会就更好）" class="headerlink" title="十四、加分项（不会也没事，会就更好）"></a>十四、加分项（不会也没事，会就更好）</h3><p>14.1、OpenGL ES</p><p>14.2、逆向</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、UI视图&quot;&gt;&lt;a href=&quot;#一、UI视图&quot; class=&quot;headerlink&quot; title=&quot;一、UI视图&quot;&gt;&lt;/a&gt;一、UI视图&lt;/h3&gt;&lt;p&gt;1.1 、事件传递机制&lt;/p&gt;
&lt;p&gt;1.2 、UI绘制原理&lt;/p&gt;
&lt;p&gt;1.3 、异步绘制原理&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS面试题收录（二）</title>
    <link href="http://yoursite.com/2020/05/08/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2020/05/08/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2020-05-08T13:02:13.000Z</published>
    <updated>2020-05-11T01:47:05.483Z</updated>
    
    <content type="html"><![CDATA[<p>主题：怎么做？</p><h4 id="设计模式是什么？-你知道哪些设计模式，并简要叙述？"><a href="#设计模式是什么？-你知道哪些设计模式，并简要叙述？" class="headerlink" title="设计模式是什么？ 你知道哪些设计模式，并简要叙述？"></a>设计模式是什么？ 你知道哪些设计模式，并简要叙述？</h4><p><strong>设计模式</strong>是一套被 反复使用、多数人知晓、经过分类编目的、代码设计经验的总结。</p><p><strong>单例模式：</strong>单例模式确保某一个类只有一个实例，并提供一个访问它的全剧访问点。<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F4a1dYXPf1oSfZYS7J1IQRA" target="_blank" rel="noopener">具体的详情可点击进入查看</a><br><strong>工厂模式：</strong>工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生产具体的产品对象，即通过不停的工厂子类来创建不同的产品对象。<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fjuejin.im%2Fpost%2F5bcb0362e51d450e7042eb6d" target="_blank" rel="noopener">具体的详情可点击进入查看</a><br><strong>代理模式 :</strong>为某个对象提供一个代理，并由这个代理对象控制对原对象的访问。<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F22eVsnQP2cTccWwIaLfz5g" target="_blank" rel="noopener">具体的详情可点击进入查看</a><br><strong>适配器模式：</strong> 将一个接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。适配器模式的别名是包装器模式（Wrapper），是一种结构型设计模式。<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F3abKTDIVy8BJJjThr2jgMQ" target="_blank" rel="noopener">具体的详情可点击进入查看</a><br><strong>装饰者模式：</strong> 不改变原有对象的前提下，动态地给一个对象增加一些额外的功能。<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FkoaeYH1U-nfrsSQ8FH3hhQ" target="_blank" rel="noopener">具体的详情可点击进入查看</a></p><h4 id="MVC-和-MVVM-的区别？"><a href="#MVC-和-MVVM-的区别？" class="headerlink" title="MVC 和 MVVM 的区别？"></a>MVC 和 MVVM 的区别？</h4><p><strong>MVC</strong><br>MVC（Model-View-Controller）模式结构图，可分为三部分：模型（Model）、视图（View）、控制器（Controller）。其在MVC模式中所扮演的角色分别为：<br>Model：模型管理应用程序的数据，响应有关其状态信息（通常来自View）的请求，并响应指令以更改状态（通常来自Controller）。<br>View：视图管理数据的展示。<br>Controller：控制器解释用户的输入，并通知模型、视图进行状态更新<br>所有通信都是单向的。<br>优点：对Controller进行瘦身，将View内部的细节封装起来了，外界不知道View内部的具体实现<br>缺点：View和Controller依赖于Model</p><p><strong>MVVM</strong><br>MVVM（Model View View-Model）就是为了解决过于臃肿的问题。MVVM的思想是将Controller中UI控制逻辑与业务逻辑进行分离，并抽离出一个View-Model来完成UI控制的逻辑。而Controller只需要负责业务逻辑即可</p><p>唯一的区别是，View-Model可以调用Model定义的方法，从Model中获取数据以用于View，并对数据进行预处理，使View可以直接使用。View又可以向View-Model发出用户的操作命令，从而更改Model。MVVM实现了一种双向绑定机制。</p><p>优点：降低了View和Model之间的耦合；分离了业务逻辑和视图逻辑。<br>缺点：View和Model双向绑定导致bug难以定位，两者中的任何一方出现问题，另一方也会出现问题；增加了胶水代码</p><h4 id="iOS-内存的使用和优化的注意事项"><a href="#iOS-内存的使用和优化的注意事项" class="headerlink" title="iOS 内存的使用和优化的注意事项?"></a>iOS 内存的使用和优化的注意事项?</h4><p><strong>重用问题：</strong>如<code>UITableViewCells</code>、<code>UICollectionViewCells</code>、<code>UITableViewHeaderFooterViews</code>。设置正确的<code>reuseIdentifier</code>，充分重用<br><strong>不要使用太复杂的XIB/Storyboard：</strong>载入时就会将<code>XIB</code>/<code>storyboard</code>需要的所有资源，包括图片全部载入内存。<br><strong>尽量把views设置为不透明：</strong>当opque为NO的时候，图层的半透明取决于图片和其本身合成的图层为结果，可提高性能<br><strong>选择正确的数据结构：</strong>学会选择对业务场景最合适的数组结构是写出高效代码的基础。<br><strong>gzip/zip压缩：</strong>当从服务端下载相关附件时，可以通过gzip/zip压缩后再下载，使得内存更小，下载速度也更快。<br><strong>延迟加载：</strong>对于不应该使用的数据，使用延迟加载方式。对于不需要马上显示的视图，使用延迟加载方式。比如，网络请求失败时显示的提示界面，可能一直都不会使用到，因此应该使用延迟加载。<br><strong>数据缓存：</strong>对于cell的行高要缓存起来，使得reload数据时，效率也极高。<br>而对于那些网络数据，不需要每次都请求的，应该缓存起来。可以写入数据库，也可以通过plist文件存储<br><strong>处理内存警告：</strong>一般在基类统一处理内存警告，将相关不用资源立即释放掉</p><h4 id="iOS-你在项目中是怎么优化内存的？"><a href="#iOS-你在项目中是怎么优化内存的？" class="headerlink" title="iOS 你在项目中是怎么优化内存的？"></a>iOS 你在项目中是怎么优化内存的？</h4><blockquote><p>这个问题有时候笔试中也有，有时候有些面试官会在面试中问你这个问题</p></blockquote><p>1&gt;.避免庞大的Xib(Xib比frame消耗更多的CPU资源)<br>2&gt;.不要阻塞主线程，尽量把耗时的操作放到子线程<br>3&gt;.重用和延迟加载<br>4&gt;.尽量减少视图数量和层次<br>5&gt;.优化TableView,为了使TableVIew有更好的滚动性能可采取以下措施：</p><ul><li>正确使用ruseIdentifier来重用cells</li><li>采用懒加载即延迟加载的方式加载cell上的控件</li><li>当TableView滑动的时候不加载</li><li>缓存cell的高度。在呈现cell前，把cell的高度计算好缓存起来，避免每次加载cell的时候都要计算</li><li>尽量使用不透明的UI控件</li></ul><h4 id="写一个完整的代理，包括声明、实现"><a href="#写一个完整的代理，包括声明、实现" class="headerlink" title="写一个完整的代理，包括声明、实现"></a>写一个完整的代理，包括声明、实现</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">PersonDelagate</span></span></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line">-(<span class="keyword">void</span>)eat:(<span class="built_in">NSString</span> *)foodName;</span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">-(<span class="keyword">void</span>)run;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 .h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>: <span class="title">NSObject</span>&lt;<span class="title">PersonDelagate</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 .m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)eat:(<span class="built_in">NSString</span> *)foodName &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"吃:%@"</span>, foodName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"run"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="分析json、xml-的区别-json、xml-解析-式的底层是如何让处理的"><a href="#分析json、xml-的区别-json、xml-解析-式的底层是如何让处理的" class="headerlink" title="分析json、xml 的区别? json、xml 解析 式的底层是如何让处理的"></a>分析json、xml 的区别? json、xml 解析 式的底层是如何让处理的</h4><p>(一) JSON与XML的区别： </p><p>（1）可读性方面：基本相同，XML的可读性比较好； </p><p>（2）可扩展性方面：都具有良好的扩展性； </p><p>（3）编码难度方面：相对而言，JSON的编码比较容易； </p><p>（4）解码难度：JSON的解码难度基本为零，XML需要考虑子节点和父节点；</p><p>（5）数据体积方面：JSON相对于XML来讲，数据体积小，传递的速度比较快； </p><p>（6）数据交互方面：JSON与javascript的交互更加方便，更容易解析处理，更好的数据交互； </p><p>（7）数据描述方面：XML对数据描述性比较好 </p><p>（8）传输速度方面：JSON的速度远远快于XML。 </p><p>(二）JSON与XML底层实现原理： 　</p><p>（1）JSON底层原理：遍历字符串中的字符，最终根据格式规定的特殊字符，比如{}、[]、：等进行区分，{}号表示字典，[]号表示数组，：号是字典的键和值的分水岭，最终仍是将JSON转化为字典，只不过字典中的值可能是“字典、数组或者字符串而已”。 　　</p><p>（2）XML底层原理：XML解析常用的解析方法有两种：DOM解析和SAX解析；DOM采用的是树形结构的方式访问XML文档，而SAX采用的是事件模型；DOM解析把XML文档转化为一个包含其内容的树，并可以对树进行遍历，使用DOM解析器的时候需要处理整个XML文档，所以对内存和性能的要求比较高；SAX在解析XML文档的时候可以触发一系列的事件，当发现给定的tag的时候，他可以激活一个回调方法，告诉该方法指定的标签已经找到，SAX对内存的要求通常会比较低，因为他让开发人员自己来决定所要处理的tag，特别是当开发人员只需要处理文档中所包含部分数据时，SAX这种扩展能力得到了更好的体现。</p><h4 id="如何处理UITableVier-中Cell-动态计算高度的问题，都有哪些方案"><a href="#如何处理UITableVier-中Cell-动态计算高度的问题，都有哪些方案" class="headerlink" title="如何处理UITableVier 中Cell 动态计算高度的问题，都有哪些方案?"></a>如何处理UITableVier 中Cell 动态计算高度的问题，都有哪些方案?</h4><ol><li><p>你的Cell要使用AutoLayout来布局约束这是必须的； 设置tableview的estimatedRowHeight为一个非零值，这个属性是设置一个预估的高度值，不用太精确。 设置tableview的rowHeight属性为UITableViewAutomaticDimension</p></li><li><p>第三方 UITableView+FDTemplateLayoutCell</p></li></ol><h4 id="怎么高效的实现控件的圆角效果"><a href="#怎么高效的实现控件的圆角效果" class="headerlink" title="怎么高效的实现控件的圆角效果"></a>怎么高效的实现控件的圆角效果</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绘制圆角 </span></span><br><span class="line">-(<span class="built_in">UIImageView</span> *)roundedRectImageViewWithCornerRadius:(<span class="built_in">CGFloat</span>)cornerRadius &#123; </span><br><span class="line">  <span class="built_in">UIBezierPath</span> *bezierPath = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="keyword">self</span>.bounds cornerRadius:cornerRadius]; </span><br><span class="line">  <span class="built_in">CAShapeLayer</span> *layer = [<span class="built_in">CAShapeLayer</span> layer]; </span><br><span class="line">  layer.path = bezierPath.CGPath; </span><br><span class="line">  <span class="keyword">self</span>.layer.mask = layer; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="假如Controller太臃肿，如何优化"><a href="#假如Controller太臃肿，如何优化" class="headerlink" title="假如Controller太臃肿，如何优化?"></a>假如Controller太臃肿，如何优化?</h4><ol><li><p>将网络请求抽象到单独的类中 方便在基类中处理公共逻辑； 方便在基类中处理缓存逻辑，以及其它一些公共逻辑； 方便做对象的持久化。 </p></li><li><p>将界面的封装抽象到专门的类中 构造专门的 UIView 的子类，来负责这些控件的拼装。这是最彻底和优雅的方式，不过稍微麻烦一些的是，你需要把这些控件的事件回调先接管，再都一一暴露回 Controller。 </p></li><li><p>构造 ViewModel 借鉴MVVM。具体做法就是将 ViewController 给 View 传递数据这个过程，抽象成构造 ViewModel 的过程。 </p></li><li><p>专门构造存储类 专门来处理本地数据的存取。 </p></li><li><p>整合常量</p></li></ol><h4 id="项目中网络层如何做安全处理"><a href="#项目中网络层如何做安全处理" class="headerlink" title="项目中网络层如何做安全处理?"></a>项目中网络层如何做安全处理?</h4><ol><li>判断API的调用请求是否来自于经过授权的APP。如若不是则拒绝请求访问 </li><li>在数据请求的过程中进行URL加密处理：防止反编译，接口信息被静态分析。 </li><li>数据传输加密：对客户端传输数据提供有效的加密方案，以防止网络接口的拦截。 如果可以尽量使用HTTPS，可以有效的避免接口数据在传输中被攻击。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主题：怎么做？&lt;/p&gt;
&lt;h4 id=&quot;设计模式是什么？-你知道哪些设计模式，并简要叙述？&quot;&gt;&lt;a href=&quot;#设计模式是什么？-你知道哪些设计模式，并简要叙述？&quot; class=&quot;headerlink&quot; title=&quot;设计模式是什么？ 你知道哪些设计模式，并简要叙述？&quot;&gt;
      
    
    </summary>
    
    
      <category term="iOS面试汇总" scheme="http://yoursite.com/categories/iOS%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS面试题收录（一）</title>
    <link href="http://yoursite.com/2020/05/08/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/05/08/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-05-08T12:03:48.000Z</published>
    <updated>2020-05-11T01:47:05.482Z</updated>
    
    <content type="html"><![CDATA[<p>主题：是什么？</p><h4 id="关键字const什么含义？"><a href="#关键字const什么含义？" class="headerlink" title="关键字const什么含义？"></a>关键字const什么含义？</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> a;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *a;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *a;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> a;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * <span class="keyword">const</span> a;</span><br></pre></td></tr></table></figure><p>1&gt;. 前两个的作用是一样：a 是一个常整型数<br>2&gt;. 第三、四个意味着 a 是一个指向常整型数的指针(整型数是不可修改的，但指针可以)<br>3&gt;. 第五个的意思：a 是一个指向整型数的常指针(指针指向的整型数是可以修改的，但指针是不可修改的)<br>4&gt;. 最后一个意味着：a 是一个指向常整型数的常指针(指针指向的整型数是不可修改的，同时指针也是不可修改的)</p><h4 id="import跟-include-有什么区别，-class呢，-import-lt-gt-跟-import“”有什么区别？"><a href="#import跟-include-有什么区别，-class呢，-import-lt-gt-跟-import“”有什么区别？" class="headerlink" title="#import跟 #include 有什么区别，@class呢，#import&lt;&gt; 跟 #import“”有什么区别？"></a>#import跟 #include 有什么区别，@class呢，#import&lt;&gt; 跟 #import“”有什么区别？</h4><ol><li><p>#import是Objective-C导入头文件的关键字，#include是C/C++导入头文件的关键字，使用#import头文件会自动只导入一次，不会重复导入。</p></li><li><p>@class告诉编译器某个类的声明，当执行时，才去查看类的实现文件，可以解决头文件的相互包含。</p></li><li><p>#import&lt;&gt;用来包含系统的头文件，#import””用来包含用户头文件。</p></li></ol><h4 id="property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的？"><a href="#property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的？" class="headerlink" title="@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的？"></a>@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的？</h4><p>@property 的本质是:@property = ivar + getter + setter</p><p>“属性” (property)有两大概念：ivar（实例变量）、getter+setter（存取方法）</p><p>“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。</p><h4 id="property中有哪些属性关键字以及作用？"><a href="#property中有哪些属性关键字以及作用？" class="headerlink" title="@property中有哪些属性关键字以及作用？"></a>@property中有哪些属性关键字以及作用？</h4><p><strong>线程安全</strong></p><p><strong>nonatomic ：</strong>非原子操作。决定编译器生成的setter和getter方法是否是原子操作，一般使用nonatomic，效率高。<br><strong>atomic：</strong>多线程安全，但是性能低</p><p><strong>内存管理</strong></p><p><strong>strong：</strong>持有特性。setter方法将传入参数先保留，再赋值，传入参数的retaincount会+1。<br><strong>copy ：</strong>拷贝特性。setter方法将传入对象复制一份，需要完全一份新的变量时。<br><strong>assign：</strong>用于基本数据类型<br><strong>retain</strong>：相当于ARC中的strong</p><p><strong>读写操作</strong></p><p><strong>readwrite：</strong>可读可写特性。需要生成getter方法和setter方法<br><strong>readonly：</strong>只读特性。只会生成getter方法，不会生成setter方法，不希望属性在类外改变。</p><h4 id="什么情况使用-weak-关键字，相比-assign-有什么不同？"><a href="#什么情况使用-weak-关键字，相比-assign-有什么不同？" class="headerlink" title="什么情况使用 weak 关键字，相比 assign 有什么不同？"></a>什么情况使用 weak 关键字，相比 assign 有什么不同？</h4><p>1&gt;.在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性。<br>2&gt;.自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak（因为父控件的subViews数组已经对它有一个强引用）。</p><p>不同点：<br>assign 可以用非 OC 对象，而 weak 必须用于 OC 对象。<br>weak 表明该属性定义了一种“非拥有关系”。在属性所指的对象销毁时，属性值会自动清空(nil)。</p><h4 id="用-property声明的-NSString-NSArray-NSDictionary-经常使用-copy-关键字，为什么？如果改用strong关键字，可能造成什么问题？"><a href="#用-property声明的-NSString-NSArray-NSDictionary-经常使用-copy-关键字，为什么？如果改用strong关键字，可能造成什么问题？" class="headerlink" title="用@property声明的 NSString / NSArray / NSDictionary 经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？"></a>用@property声明的 NSString / NSArray / NSDictionary 经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？</h4><p>用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作（就是把可变的赋值给不可变的），为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p><p>1&gt;. 因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本。<br>2&gt;. 如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。<br>总结：使用copy的目的是，防止把可变类型的对象赋值给不可变类型的对象时，可变类型对象的值发送变化会无意间篡改不可变类型对象原来的值。</p><h4 id="浅拷贝和深拷贝的区别？"><a href="#浅拷贝和深拷贝的区别？" class="headerlink" title="浅拷贝和深拷贝的区别？"></a>浅拷贝和深拷贝的区别？</h4><p><strong>浅拷贝：</strong>对一个对象地址的拷贝。源对象和副本对象是同一对象<br><strong>深拷贝：</strong>对一个对象的拷贝。源对象和副本对象是不同的两个对象</p><h4 id="self-跟self-gt-什么区别？"><a href="#self-跟self-gt-什么区别？" class="headerlink" title="self.跟self-&gt;什么区别？"></a>self.跟self-&gt;什么区别？</h4><p>1&gt;. self.是调用get方法或者set放<br>2&gt;. self是当前本身，是一个指向当前对象的指针<br>3&gt;. self-&gt;是直接访问成员变量</p><h4 id="一个objc对象的isa的指针指向什么？有什么作用？"><a href="#一个objc对象的isa的指针指向什么？有什么作用？" class="headerlink" title="一个objc对象的isa的指针指向什么？有什么作用？"></a>一个objc对象的isa的指针指向什么？有什么作用？</h4><p>指向他的类对象,从而可以找到对象上的方法</p><h4 id="frame-和-bounds-有什么不同？"><a href="#frame-和-bounds-有什么不同？" class="headerlink" title="frame 和 bounds 有什么不同？"></a>frame 和 bounds 有什么不同？</h4><p><strong>frame：</strong>该view在父view坐标系统中的位置和大小。(参照点是父view的坐标系统)</p><p><strong>bounds：</strong>该view在本身坐标系统中的位置和大小。(参照点是本身坐标系统)</p><h4 id="Objective-C的类可以多重继承么？没有的话用什么代替？可以实现多个接口么？Category是什么？重写一个类的方式用继承好还是分类好？为什么？"><a href="#Objective-C的类可以多重继承么？没有的话用什么代替？可以实现多个接口么？Category是什么？重写一个类的方式用继承好还是分类好？为什么？" class="headerlink" title="Objective-C的类可以多重继承么？没有的话用什么代替？可以实现多个接口么？Category是什么？重写一个类的方式用继承好还是分类好？为什么？"></a>Objective-C的类可以多重继承么？没有的话用什么代替？可以实现多个接口么？Category是什么？重写一个类的方式用继承好还是分类好？为什么？</h4><p>OC不可以多继承，OC是单继承。有时可以用分类和协议来代替多继承<br>可以实现多个接口（协议）<br>Category是类别；一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。</p><h4 id="Object-C有私有方法吗？私有变量呢？"><a href="#Object-C有私有方法吗？私有变量呢？" class="headerlink" title="Object-C有私有方法吗？私有变量呢？"></a>Object-C有私有方法吗？私有变量呢？</h4><p>1&gt;.OC没有类似@private的修饰词来修饰方法，只要写在.h文件中，就是公共方法<br>2&gt;. 如果你不在.h文件中声明，只在.m文件中实现，或在.m文件的Class Extension里声明，那么基本上和私有方法差不多，可以使用类扩展（Extension）来增加私有方法和私有变量<br>3&gt;. 使用private修饰的全局变量是私有变量</p><h4 id="用伪代码写一个线程安全的单例模式"><a href="#用伪代码写一个线程安全的单例模式" class="headerlink" title="用伪代码写一个线程安全的单例模式"></a>用伪代码写一个线程安全的单例模式</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> XXManager * instance = <span class="literal">nil</span>;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)shareInstance &#123;</span><br><span class="line">      <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">      <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        instance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">      <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        instance = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="category-类别-和-extension-扩展-的区别"><a href="#category-类别-和-extension-扩展-的区别" class="headerlink" title="category(类别) 和 extension(扩展) 的区别"></a>category(类别) 和 extension(扩展) 的区别</h4><p>1&gt;. 类别有名字，类扩展没有分类名字，是一种特殊的分类。<br>2&gt;. 类别只能扩展方法（属性仅仅是声明，并没真正实现），类扩展可以扩展属性、成员变量和方法。<br>3&gt;. 继承可以增加，修改或者删除方法，并且可以增加属性。</p><h4 id="delegate-和-notification-的区别"><a href="#delegate-和-notification-的区别" class="headerlink" title="delegate 和 notification 的区别"></a>delegate 和 notification 的区别</h4><p>二者都用于传递消息，不同之处主要在于一个是一对一的，另一个是一对多的<br><strong>notification：</strong>不需要两者之间有联系,实现一对多消息的转发<br><strong>delegate：</strong>需要两者之间必须建立联系，不然没法调用代理的方法</p><h4 id="Objective-C-如何对内存管理的，说说你的看法和解决方法？"><a href="#Objective-C-如何对内存管理的，说说你的看法和解决方法？" class="headerlink" title="Objective-C 如何对内存管理的，说说你的看法和解决方法？"></a>Objective-C 如何对内存管理的，说说你的看法和解决方法？</h4><p>Objective-C的内存管理主要有三种方式ARC(自动内存计数)、手动内存计数、内存池。<br>1&gt;. 自动内存计数ARC：由Xcode自动在App编译阶段，在代码中添加内存管理代码。<br>2&gt;. 手动内存计数MRC：遵循内存谁申请、谁释放；谁添加，谁释放的原则。<br>3&gt;. 内存释放池Release Pool：把需要释放的内存统一放在一个池子中，当池子被抽干后(drain)，池子中所有的内存空间也被自动释放掉。内存池的释放操作分为自动和手动。自动释放受runloop机制影响。</p><h4 id="GCD-与-NSOperation-的区别"><a href="#GCD-与-NSOperation-的区别" class="headerlink" title="GCD 与 NSOperation 的区别"></a>GCD 与 NSOperation 的区别</h4><p><strong>NSOperation:</strong>相对于GCD来说，更加强大。可以给operation之间添加依赖关系、取消一个正在执行的operation、暂停和恢复operationQueue等</p><p><strong>GCD:</strong> 是一种更轻量级的，以FIFO(先进先出，后进后出)的顺序执行并发任务。使用GCD我们并不用关心任务的调度情况，而是系统会自动帮我们处理。但是GCD的短板也是非常明显的，比如我们想要给任务之间添加依赖关系、取消或者暂停一个正在执行的任务时就会变得束手无策。</p><h4 id="OC中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？"><a href="#OC中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？" class="headerlink" title="OC中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？"></a>OC中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程的方法</span></span><br><span class="line"></span><br><span class="line">- [<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="literal">nil</span> toTarget:<span class="literal">nil</span> withObject:<span class="literal">nil</span>]</span><br><span class="line"></span><br><span class="line">- [<span class="keyword">self</span> performSelectorInBackground:<span class="literal">nil</span> withObject:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">- [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="literal">nil</span> selector:<span class="literal">nil</span> object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">- <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;&#125;);</span><br><span class="line"></span><br><span class="line">- [[<span class="built_in">NSOperationQueue</span> new] addOperation:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程中执行代码的方法</span></span><br><span class="line"></span><br><span class="line">- [<span class="keyword">self</span> performSelectorOnMainThread:<span class="literal">nil</span> withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line">- <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;&#125;);</span><br><span class="line"></span><br><span class="line">- [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperation:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><h4 id="runloop-和线程有什么关系"><a href="#runloop-和线程有什么关系" class="headerlink" title="runloop 和线程有什么关系?"></a>runloop 和线程有什么关系?</h4><p>runloop与线程是一一对应的，一个runloop对应一个核心的线程，为什么说是核心的，是因为runloop是可以嵌套的，但是核心的只能有一个，他们的关系保存在一个全局的字典里。 runloop是来管理线程的，当线程的runloop被开启后，线程会在执行完任务后进入休眠状态，有了任务就会被唤醒去执行任务。 runloop在第一次获取时被创建，在线程结束时被销毁。 对于主线程来说，runloop在程序一启动就默认创建好了。 对于子线程来说，runloop是懒加载的，只有当我们使用的时候才会创建，所以在子线程用定时器要注意：确保子线程的runloop被创建，不然定时器不会回调。</p><h4 id="介绍下layoutSubview和drawRect"><a href="#介绍下layoutSubview和drawRect" class="headerlink" title="介绍下layoutSubview和drawRect"></a>介绍下layoutSubview和drawRect</h4><p>layoutSubviews调用情况</p><ul><li><p>init初始化UIView不会触发调用 </p></li><li><p>addSubview会触发调用 </p></li><li><p>改变view的width和height的时候回触发</p></li><li><p>调用 一个UIScrollView滚动会触发调用 </p></li><li><p>旋转screen会触发调用 </p></li><li><p>改变一个UIView大小的时候会触发</p></li><li><p>superView的layoutSubviews事件 直接调用setLayoutSubviews会触发调用 </p></li><li><p>-(void)viewWillAppear:(BOOL)animated会触发一次调用</p></li><li><p>-(void)viewDidAppear:(BOOL)animated 看情况</p><p>可能有调用 drawRect调用情况 </p></li><li><p>如果UIView没有设置frame大小，直接导致drawRect不能被自动调用。 </p></li><li><p>drawRect在loadView和viewDidLoad这两个方法之后调用 调用sizeToFit后自动调用drawRect </p></li><li><p>通过设置contentMode值为UIViewContentModeRedraw。那么每次设置或者更改frame自动调用drawRect。 </p></li><li><p>直接调用setNeedsDisplay或者setNeedsDisplayInRect会触发调用</p></li></ul><h4 id="UIview-和CAlayer-是什么关系-你-CLayer做过什么"><a href="#UIview-和CAlayer-是什么关系-你-CLayer做过什么" class="headerlink" title="UIview 和CAlayer 是什么关系? 你 CLayer做过什么?"></a>UIview 和CAlayer 是什么关系? 你 CLayer做过什么?</h4><p>区别： 首先UIView可以响应事件，Layer不可以.</p><p>关系：</p><ol><li>UIView是CALayer的delegate </li><li>UIView主要处理事件，CALayer负责绘制就更好 </li><li>每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，并且 UIView 的尺寸样式都由内部的 Layer 所提供。两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews.但是 Layer 比 View 多了个AnchorPoint </li></ol><p>用layer做过什么：创建隐式动画 绘制边框圆角</p><h4 id="iOS-UIViewController的完整生命周期"><a href="#iOS-UIViewController的完整生命周期" class="headerlink" title="iOS UIViewController的完整生命周期?"></a>iOS UIViewController的完整生命周期?</h4><p>按照执行顺序排列：</p><p>1&gt;. <code>initWithCoder：</code>通过nib文件初始化时触发。<br>2&gt;. <code>awakeFromNib：</code>nib文件被加载的时候，会发生一个<code>awakeFromNib</code>的消息到nib文件中的每个对象。<br>3&gt;. <code>loadView：</code>开始加载视图控制器自带的view。<br>4&gt;. <code>viewDidLoad：</code>视图控制器的view被加载完成。<br>5&gt;. <code>viewWillAppear：</code>视图控制器的view将要显示在window上。<br>6&gt;. <code>updateViewConstraints：</code>视图控制器的view开始更新AutoLayout约束。<br>7&gt;. <code>viewWillLayoutSubviews：</code>视图控制器的view将要更新内容视图的位置。<br>8&gt;. <code>viewDidLayoutSubviews：</code>视图控制器的view已经更新视图的位置。<br>9&gt;. <code>viewDidAppear：</code>视图控制器的view已经展示到window上。<br>10&gt;. <code>viewWillDisappear：</code>视图控制器的view将要从window上消失。<br>11&gt;.<code>viewDidDisappear：</code>视图控制器的view已经从window上消失。</p><h4 id="tableView的重用机制？"><a href="#tableView的重用机制？" class="headerlink" title="tableView的重用机制？"></a>tableView的重用机制？</h4><p>UITableView 通过重用单元格来达到节省内存的目的: 通过为每个单元格指定一个重用标识符，即指定了单元格的种类,当屏幕上的单元格滑出屏幕时，系统会把这个单元格添加到重用队列中，等待被重用，当有新单元格从屏幕外滑入屏幕内时，从重用队列中找看有没有可以重用的单元格，如果有，就拿过来用，如果没有就创建一个来使用</p><h4 id="NSIRLConnection-和NSLRLSession-的区别是-么-NSURLProtocol是做什么的"><a href="#NSIRLConnection-和NSLRLSession-的区别是-么-NSURLProtocol是做什么的" class="headerlink" title="NSIRLConnection 和NSLRLSession 的区别是 么? NSURLProtocol是做什么的?"></a>NSIRLConnection 和NSLRLSession 的区别是 么? NSURLProtocol是做什么的?</h4><ol><li><p>下载 NSURLConnection下载文件时，先是将整个文件下载到内存，然后再写入到沙盒，如果文件比较大，就会出现内存暴涨的情况。 而使用NSURLSessionUploadTask下载文件，会默认下载到沙盒中的tem文件中，不会出现内存暴涨的情况，但是在下载完成后会把tem中的临时文件删除，需要在初始化任务方法时，在completionHandler回调中增加保存文件的代码 </p></li><li><p>请求方法的控制 NSURLConnection实例化对象，实例化开始，默认请求就发送(同步发送),不需要调用start方法。而cancel可以停止请求的发送，停止后不能继续访问，需要创建新的请求。 NSURLSession有三个控制方法，取消(cancel)、暂停(suspend)、继续(resume)，暂停以后可以通过继续恢复当前的请求任务。 使用NSURLSession进行断点下载更加便捷. NSURLSession的构造方法（sessionWithConfiguration:delegate:delegateQueue）中有一个NSURLSessionConfiguration类的参数可以设置配置信息，其决定了cookie，安全和高速缓存策略，最大主机连接数，资源管理，网络超时等配置。NSURLConnection不能进行这个配置，相比较与NSURLConnection依赖与一个全局的配置对象，缺乏灵活性而言，NSURLSession有很大的改进</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主题：是什么？&lt;/p&gt;
&lt;h4 id=&quot;关键字const什么含义？&quot;&gt;&lt;a href=&quot;#关键字const什么含义？&quot; class=&quot;headerlink&quot; title=&quot;关键字const什么含义？&quot;&gt;&lt;/a&gt;关键字const什么含义？&lt;/h4&gt;&lt;figure class=
      
    
    </summary>
    
    
      <category term="iOS面试汇总" scheme="http://yoursite.com/categories/iOS%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
    
    
  </entry>
  
</feed>
