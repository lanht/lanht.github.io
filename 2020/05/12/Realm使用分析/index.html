<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />




  


  <link rel="alternate" href="/atom.xml" title="立码定天下" type="application/atom+xml" />






<meta name="description" content="Realm介绍 Realm数据库 打开数据库 配置 Realm 数据库 默认Realm数据库 内存中realm数据库 错误处理 预植 Realm 数据库   常用类 数据模型 支持的数据类型 必要属性 主键 索引属性 被忽略属性 默认属性值 属性特性 属性备忘单   模型继承 关系 多对一关系 多对多关系 双向关系   数据库操作 增 改 删 查   数据迁移 本地迁移 同步迁移     Rea">
<meta property="og:type" content="article">
<meta property="og:title" content="Realm使用分析">
<meta property="og:url" content="http://yoursite.com/2020/05/12/Realm%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="立码定天下">
<meta property="og:description" content="Realm介绍 Realm数据库 打开数据库 配置 Realm 数据库 默认Realm数据库 内存中realm数据库 错误处理 预植 Realm 数据库   常用类 数据模型 支持的数据类型 必要属性 主键 索引属性 被忽略属性 默认属性值 属性特性 属性备忘单   模型继承 关系 多对一关系 多对多关系 双向关系   数据库操作 增 改 删 查   数据迁移 本地迁移 同步迁移     Rea">
<meta property="article:published_time" content="2020-05-12T05:59:36.000Z">
<meta property="article:modified_time" content="2020-05-12T06:00:27.124Z">
<meta property="article:author" content="Lanht">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/05/12/Realm使用分析/"/>





  <title>Realm使用分析 | 立码定天下</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">立码定天下</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/12/Realm%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lanht">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="立码定天下">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Realm使用分析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-12T13:59:36+08:00">
                2020-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <ul>
<li><a href="#Realm">Realm介绍</a></li>
<li><a href="#Realm数据库">Realm数据库</a><ul>
<li><a href="#打开数据库">打开数据库</a></li>
<li><a href="#1配置-realm-数据库">配置 Realm 数据库</a></li>
<li><a href="#2默认Realm数据库">默认Realm数据库</a></li>
<li><a href="#3内存中-realm-数据库">内存中realm数据库</a></li>
<li><a href="#4错误处理">错误处理</a></li>
<li><a href="#5预植-Realm-数据库">预植 Realm 数据库</a></li>
</ul>
</li>
<li><a href="#常用类">常用类</a></li>
<li><a href="#数据模型">数据模型</a><ul>
<li><a href="#1支持的数据类型">支持的数据类型</a></li>
<li><a href="#2必要属性">必要属性</a></li>
<li><a href="#3主键">主键</a></li>
<li><a href="#4索引属性">索引属性</a></li>
<li><a href="#5被忽略属性">被忽略属性</a></li>
<li><a href="#6默认属性值">默认属性值</a></li>
<li><a href="#7属性特性">属性特性</a></li>
<li><a href="#8属性备忘单">属性备忘单</a></li>
</ul>
</li>
<li><a href="#模型继承">模型继承</a></li>
<li><a href="#关系">关系</a><ul>
<li><a href="#1多对一关系">多对一关系</a></li>
<li><a href="#2多对多关系">多对多关系</a></li>
<li><a href="#3双向关系">双向关系</a></li>
</ul>
</li>
<li><a href="#数据库操作-增删改查">数据库操作</a><ul>
<li><a href="#一增">增</a></li>
<li><a href="#二改">改</a></li>
<li><a href="#三删">删</a></li>
<li><a href="#四查">查</a></li>
</ul>
</li>
<li><a href="#数据迁移">数据迁移</a><ul>
<li><a href="#一本地迁移">本地迁移</a></li>
<li><a href="#二迁移同步比较复杂不常用">同步迁移</a></li>
</ul>
</li>
</ul>
<hr>
<h1 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h1><p><a href="https://realm.io/cn/docs/objc/latest/#using-the-realm-framework" target="_blank" rel="noopener">官方文档</a><br>Realm 数据库是 Realm 移动端数据库容器的一个实例。Realm 数据库可以是本地化的，也可以是可同步的。</p>
<p>RLM_ARRAY_TYPE 宏创建了一个协议，从而允许您使用 RLMArray<Dog> 这种语法。如果这条宏没有放置在模型接口定义的底部，那么这个模型类就必须前置声明。</p>
<p>注意，目前暂时不支持对包含原始类型的 RLMArray 进行查询。</p>
<p>对象的所有更改（添加、修改和删除）都必须在写入事务内完成。</p>
<p>RLMArray 只能够包含 RLMObject 类型，诸如 NSString 之类的基础类型是无法包含在内的。</p>
<p>与传统数据库相比，Realm 查询引擎的一个独特特性就是：它能够用很小的事务开销来实现链式查询，而不是每条查询都要接二连三地分别去单独访问数据库服务器。  </p>
<p>您可以订阅 Realm 通知，以了解 Realm 数据何时发生了更新，比如说可以决定应用 UI 何时进行刷新，而无需重新检索 RLMResults。</p>
<hr>
<h2 id="Realm数据库"><a href="#Realm数据库" class="headerlink" title="Realm数据库"></a>Realm数据库</h2><h3 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h3><p>要打开一个 Realm 数据库，首先需要初始化一个新的 <code>RLMRealm</code> 对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RLMRealm *realm = [RLMRealm defaultRealm];</span><br><span class="line"></span><br><span class="line">[realm transactionWithBlock:^&#123;</span><br><span class="line">    [realm addObject:mydog];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h4 id="1-配置-Realm-数据库"><a href="#1-配置-Realm-数据库" class="headerlink" title="1.配置 Realm 数据库"></a>1.配置 Realm 数据库</h4><p>在打开 <code>Realm</code> 数据库之前，可以对其进行配置。通过创建一个 <code>RLMRealmConfiguration</code> 的对象实例，然后配置相应的属性。通过创建并自定义相关的配置值，使得您可以实现个性化的设置，包括如下方面：</p>
<ul>
<li>对于本地 <code>Realm</code> 数据库而言，可以配置 <code>Realm</code> 文件在磁盘上的路径；</li>
<li>对于可同步 <code>Realm</code> 数据库而言，可以配置管理该 <code>Realm</code> 数据库的用户，以及 <code>Realm</code> 数据库在 <code>Realm</code> 对象服务器上的远程路径；</li>
<li>对于架构版本之间发生变化的 <code>Realm</code> 数据库而言，可以通过迁移功能来控制旧架构的 <code>Realm</code> 数据该如何更新到最新的架构。</li>
<li>对于存储的数据量过大、或者数据频繁发生变化的 Realm 数据库而言，可以通过压缩功能来控制 Realm 文件该如何实现压缩，从而确保能高效地利用磁盘空间。<br>要应用配置，可以在每次需要获取 Realm 实例的时候，通过向<code>+[RLMRealm realmWithConfiguration:config error:&amp;err]</code> 方法传递该配置对象，或者通过 <code>[RLMRealmConfiguration setDefaultConfiguration:config]</code> 方法，将默认 Realm 数据库的默认配置设置为我们所需的配置。</li>
</ul>
<p>例如，假设有一个应用要求用户必须要登录到 Web 后端服务器中，并且需要支持账户快速切换功能的话。 那么您可以通过以下代码，来为每个账户提供一个独立的 Realm 数据库，并且当前账户所使用的数据库将作为默认 Realm 数据库来使用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SomeClass</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)setDefaultRealmForUser:(<span class="built_in">NSString</span> *)username &#123;</span><br><span class="line">    RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用默认的目录，但是请将文件名替换为用户名</span></span><br><span class="line">    config.fileURL = [[[config.fileURL URLByDeletingLastPathComponent]</span><br><span class="line">                            URLByAppendingPathComponent:username]</span><br><span class="line">                            URLByAppendingPathExtension:<span class="string">@"realm"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将该配置设置为默认 Realm 配置</span></span><br><span class="line">    [RLMRealmConfiguration setDefaultConfiguration:config];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>您可以创建多个配置对象，这样便可以单独控制各个 Realm 数据库的版本、架构以及位置。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取预植数据库文件的 URL</span></span><br><span class="line">config.fileURL = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"MyBundledData"</span> withExtension:<span class="string">@"realm"</span>];</span><br><span class="line"><span class="comment">// 以只读模式打开该文件，这是因为应用的预植数据库是不可写的</span></span><br><span class="line">config.readOnly = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用该配置来打开 Realm 数据库</span></span><br><span class="line">RLMRealm *realm = [RLMRealm realmWithConfiguration:config error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从预植 Realm 数据库中读取某些数据</span></span><br><span class="line">RLMResults&lt;Dog *&gt; *dogs = [Dog objectsInRealm:realm where:<span class="string">@"age &gt; 5"</span>];</span><br></pre></td></tr></table></figure>

<h4 id="2-默认Realm数据库"><a href="#2-默认Realm数据库" class="headerlink" title="2.默认Realm数据库"></a>2.默认Realm数据库</h4><p>您或许已经注意到，我们是通过调用 <code>[RLMRealm defaultRealm]</code> 来初始化 realm 变量并访问的。这个方法会返回一个 <code>RLMRealm</code> 对象，该对象映射到应用 <code>Documents</code> 文件夹（iOS）或者 <code>Application Support</code> 文件夹（macOS）中的 default.realm 文件。</p>
<p>Realm API 中的许多方法都存在一个接受 <code>RLMRealm</code> 实例为参数的版本，以及另一个使用默认 <code>Realm</code> 数据库的便利版本。例如，<code>[RLMObject allObjects]</code> 等同于 <code>[RLMObject allObjectsInRealm:[RLMRealm defaultRealm]]</code>。</p>
<p>请注意，默认的 Realm 构造方法和默认的 Realm 便利方法均不允许进行错误处理；只有在初始化 Realm 数据库不可能失败的情况下，才去使用它们。欲了解更多详情，请参见文档的错误处理部分。</p>
<h4 id="3-内存中-Realm-数据库"><a href="#3-内存中-Realm-数据库" class="headerlink" title="3.内存中 Realm 数据库"></a>3.内存中 Realm 数据库</h4><p>通过配置 RLMRealmConfiguration 中的 inMemoryIdentifier 属性，而不是 fileURL 属性，这样就能够创建一个完全在内存中运行的 Realm 数据库 (in-memory Realm)，它将不会存储在磁盘当中。设置 inMemoryIdentifier 会将 fileURL 置为 nil（反之亦然）。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line">config.inMemoryIdentifier = <span class="string">@"MyInMemoryRealm"</span>;</span><br><span class="line">RLMRealm *realm = [RLMRealm realmWithConfiguration:config error:<span class="literal">nil</span>];</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>内存中 Realm 数据库无法在应用启动期间存储数据，但是 Realm 数据库的其他功能都能正常使用，包括查询、关系以及线程安全。 如果您需要提供一种灵活的数据访问方式，而不占用磁盘空间的话，那么这是一个很有用的选择。</p>
<h4 id="4-错误处理"><a href="#4-错误处理" class="headerlink" title="4.错误处理"></a>4.错误处理</h4><p>与任何磁盘 I/O 操作类似，如果资源受到限制，那么创建 RLMRealm 实例有可能会失败。实际上，只有在指定线程中第一次创建 Realm 实例时才可能会发生这种情况。在同一个线程中继续访问 Realm 数据库将会重用缓存的实例，这个操作是不可能失败的。</p>
<p>为了处理在指定线程中第一次创建 <code>Realm</code> 数据库时所发生的错误，我们提供了一个 <code>NSError</code> 指针类型的 <code>error</code> 参数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line">RLMRealm *realm = [RLMRealm realmWithConfiguration:config error:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (!realm) &#123;</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-预植-Realm-数据库"><a href="#5-预植-Realm-数据库" class="headerlink" title="5.预植 Realm 数据库"></a>5.预植 Realm 数据库</h4><p>为应用提供一些初始数据的做法非常常见，这样就让用户在首次启动时进行访问。具体做法是：</p>
<p>1.首先，向 Realm 数据库中植入数据。所使用的数据模型应当与最终发布应用时所使用的 Realm 数据模型相同，然后向数据库中写入所需要的初始数据。由于 Realm 文件是跨平台的，因此您可以使用 macOS 应用（参见我们的 JSONImport 示例）,或者运行在模拟器中的 iOS 应用来完成数据的植入；<br>2.在生成此 Realm 文件的代码中，最后您应当制作一个此数据库的压缩版本（参见 -[RLMRealm writeCopyToPath:error:])）。这可以减少 Realm 文件的大小，使您的应用体积更小，便于用户下载。<br>3.将您 Realm 文件的压缩版本拖曳到应用的 Xcode 项目导航栏中；<br>4.前往 Xcode 中应用目标的 “Build Phases” 选项卡，将 Realm 文件添加到 “Copy Bundle Resources” 构建阶段中。<br>5.此时，应用已经可以访问该预植 Realm 文件 (bundled Realm) 了。您可以使用 <code>[[NSBundle mainBundle] pathForResource:ofType:]</code> 来获取路径；<br>6.如果预植 Realm 数据库中的数据是固定不变、不需要修改的，那么您可以在 <code>RLMRealmConfiguration</code> 对象中，通过设置 readOnly = true 来直接从该路径中打开此文件。否则，如果要对初始数据进行更改的话，您需要使用<code>[[NSFileManager defaultManager] copyItemAtPath:toPath:error:]</code> 将预植文件复制到应用的 Documents 目录下。  </p>
<hr>
<h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><ul>
<li><code>Realm</code> 移动端数据库容器的一个实例</li>
<li><code>RLMRealmConfiguration</code> 在打开 Realm 数据库之前，可以对其进行配置。通过创建一个 RLMRealmConfiguration 的对象实例，然后配置相应的属性</li>
<li><code>RLMObject</code></li>
<li><code>RLMResults</code> 表示<strong>检索</strong>所返回的对象集合。</li>
<li><code>RLMArray</code> 表示模型之间的<strong>对多关系</strong>。</li>
<li>RLMLinkingObjects 类，表示模型之间的双向关系](#inverse-relationships)。</li>
<li>RLMCollection 协议，定义了所有 Realm 集合的常用接口。</li>
</ul>
<hr>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><h3 id="1-支持的数据类型"><a href="#1-支持的数据类型" class="headerlink" title="1.支持的数据类型"></a>1.支持的数据类型</h3><p>Realm 支持下述属性类型：<strong><code>BOOL</code></strong>、<strong><code>bool</code></strong>、<strong><code>int</code></strong>、<strong><code>NSInteger</code></strong>、<strong><code>long</code></strong>、<strong><code>long long</code></strong>、<strong><code>float</code></strong>、<strong><code>double</code></strong>、<strong><code>NSString</code></strong>、<strong><code>NSDate</code></strong>、<strong><code>NSData</code></strong> 以及 被特殊类型标记的 <strong><code>NSNumber</code></strong> 。</p>
<p>CGFloat 属性被取消了，因为它不具备平台独立性。</p>
<p>您可以使用 <code>RLMArray&lt;Object *&gt;&lt;Object&gt;</code> 和 RLMObject 的相关子类来构建关系模型，诸如一对多、一对一等。</p>
<p>RLMArray 支持 Objective-C 泛型。下面是不同类型的属性定义含义，以及相关用途：</p>
<ul>
<li><code>RLMArray</code> 属性类型。</li>
<li><code>&lt;Object *&gt;</code> 泛型特化。这可以在编译时防止错误对象类型数组的使用。</li>
<li><code>&lt;Object&gt;</code> RLMArray 所遵守的协议。可以让 Realm 知晓如何在运行时确定该模型的架构。</li>
</ul>
<h3 id="2-必要属性"><a href="#2-必要属性" class="headerlink" title="2.必要属性"></a>2.必要属性</h3><p>通常情况下，NSString *、NSData * 以及 NSDate * 属性可以设置为 nil。如果你必须需要这些值来进行展示的话，那么可以重写 RLMObject 子类的 +requiredProperties 方法。</p>
<p>例如，对于下述模型定义而言，尝试将 name 属性设置为 nil 将会抛出异常，但是将 birthday 属性设置为 nil 则是允许的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSDate</span> *birthday;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)requiredProperties &#123;</span><br><span class="line">    <span class="keyword">return</span> @[<span class="string">@"name"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>使用 NSNumber * 属性来存储可空数字。由于对于不同类型的数字而言，Realm 均使用了不同的存储格式，因此该属性必须由 RLMInt、RLMFloat、RLMDouble 或者 RLMBool 所标记。所有赋给该属性的值都会被转换为指定的类型。</p>
<p>请注意，NSDecimalNumber 值只能够分配给 RLMDouble 属性，并且 Realm 会存储双进度浮点数的近似值，而不是基础的十进制数值。</p>
<p>如果我们打算存储某人的年龄，而不是存储生日的话，那么还要允许不知道用户年龄的时候，可以将其设置为 nil：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSNumber</span>&lt;RLMInt&gt; *age;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)requiredProperties &#123;</span><br><span class="line">    <span class="keyword">return</span> @[<span class="string">@"name"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><strong>RLMProperty 子类属性始终可以为 nil，因此无法包含在 requiredProperties 当中，此外 RLMArray 不支持存储 nil。</strong></p>
<h3 id="3-主键"><a href="#3-主键" class="headerlink" title="3.主键"></a>3.主键</h3><p>重写 +primaryKey 可以设置模型的主键。声明主键允许对象的查询和更新更加高效，并且会强制要求每个值保持唯一性。一旦将带有主键的对象添加到 Realm 数据库，那么该对象的主键将无法更改。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSInteger</span> <span class="keyword">id</span>;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">+ (<span class="built_in">NSString</span> *)primaryKey &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"id"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="4-索引属性"><a href="#4-索引属性" class="headerlink" title="4.索引属性"></a>4.索引属性</h3><p>要为某个属性建立索引，那么重写 +indexedProperties 即可。与主键类似，索引会稍微减慢写入速度，但是使用比较运算符进行查询的速度将会更快（它同样会造成 Realm 文件体积的增大，因为需要存储索引。）当您需要为某些特定情况优化读取性能的时候，那么最好添加索引。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Book</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">float</span> price;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *title;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Book</span></span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)indexedProperties &#123;</span><br><span class="line">    <span class="keyword">return</span> @[<span class="string">@"title"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="5-被忽略属性"><a href="#5-被忽略属性" class="headerlink" title="5.被忽略属性"></a>5.被忽略属性</h3><p>如果您不想将模型中的某些字段保存在 Realm 数据库中，那么可以重写 +ignoredProperties。Realm 不会干涉这些属性的正常操作；它们被成员变量所持有，并且可以随意重写它们的 Setter 和 Getter。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSInteger</span> tmpID;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name; <span class="comment">// 只读属性会被自动忽略</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *firstName;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *lastName;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)ignoredProperties &#123;</span><br><span class="line">    <span class="keyword">return</span> @[<span class="string">@"tmpID"</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ %@"</span>, <span class="keyword">self</span>.firstName, <span class="keyword">self</span>.lastName];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>被忽略属性的行为与正常属性完全相同。不过它们不支持 Realm 属性所特有的功能（例如：无法在查询中使用，也无法触发通知）。这些属性仍能够使用 KVO 进行观察。</p>
<h3 id="6-默认属性值"><a href="#6-默认属性值" class="headerlink" title="6.默认属性值"></a>6.默认属性值</h3><p>重写 <code>+defaultPropertyValues</code>， 可以在每次创建对象时为属性提供默认值。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Book</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">float</span> price;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *title;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Book</span></span></span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)defaultPropertyValues &#123;</span><br><span class="line">    <span class="keyword">return</span> @&#123;<span class="string">@"price"</span> : @<span class="number">0</span>, <span class="string">@"title"</span>: <span class="string">@""</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="7-属性特性"><a href="#7-属性特性" class="headerlink" title="7.属性特性"></a>7.属性特性</h3><p>Realm 将会忽略诸如 <code>nonatomic</code>、<code>atomic</code>、<code>strong</code>、<code>copy</code>、<code>weak</code> 之类的 Objective-C 属性特性。这些特性对于 Realm 存储机制而言并没有意义。Realm 有自己优化过的存储语义。所以为了避免有人对代码产生误解，我们建议您在编写模型时不要附加任何属性特性。不过，如果您切实设置了属性特性，那么在有 <code>RLMObject</code> 被写入到 Realm 数据库之前，这些属性特性都会一直生效。</p>
<p>无论该 <code>RLMObject</code> 对象是否被 Realm 数据库所管理，Getter 和 Setter 的自定名称仍然可以正常使用。</p>
<p>由于未被管理的 Realm 对象（即不被 Realm 数据库所管理的 Realm 模型类实例）只是单纯的 NSObject 子类，因此其中的属性特性可以像其他 NSObject 对象一样被观察到。</p>
<p>如果在 Swift 中使用 Realm Objective-C，那么模型属性需要添加 @objc dynamic var 特性，才能使这些属性能够访问到底层数据库的数据。（您同样可以用 objcMembers 来声明类，然后使用 dynamic var 来声明模型属性。）</p>
<h3 id="8-属性备忘单"><a href="#8-属性备忘单" class="headerlink" title="8.属性备忘单"></a>8.属性备忘单</h3><p>这个表格提供了声明模型属性的简易参考：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>非可空值形式</th>
<th>可空值形式</th>
</tr>
</thead>
<tbody><tr>
<td>Bool</td>
<td>@property BOOL value;</td>
<td>@property NSNumber<RLMBool> *value;</td>
</tr>
<tr>
<td>Int</td>
<td>@property int value;</td>
<td>@property NSNumber<RLMInt> *value;</td>
</tr>
<tr>
<td>Float</td>
<td>@property float value;</td>
<td>@property NSNumber<RLMFloat> *value;</td>
</tr>
<tr>
<td>Double</td>
<td>@property double value;</td>
<td>@property NSNumber<RLMDouble> *value;</td>
</tr>
<tr>
<td>String</td>
<td>@property NSString *value; 1</td>
<td>@property NSString *value;</td>
</tr>
<tr>
<td>Data</td>
<td>@property NSData *value; 1</td>
<td>@property NSData *value;</td>
</tr>
<tr>
<td>Date</td>
<td>@property NSDate *value; 1</td>
<td>@property NSDate *value;</td>
</tr>
<tr>
<td>Object</td>
<td>不存在：必须是可空值</td>
<td>@property Object *value;</td>
</tr>
<tr>
<td>List</td>
<td>@property RLMArray&lt;Class *&gt;<Class> *value;</td>
<td>不存在：必须是非可空值</td>
</tr>
<tr>
<td>LinkingObjects</td>
<td>@property (readonly) RLMLinkingObjects&lt;Object *&gt; *value; 2</td>
<td>不存在：必须是非可空值</td>
</tr>
</tbody></table>
<hr>
<h2 id="模型继承"><a href="#模型继承" class="headerlink" title="模型继承"></a>模型继承</h2><p>Realm 允许对模型进行多级继承，从而允许跨模型实现代码复用，但是某些 Cocoa 特性是没有办法使用的，比如说那些支撑运行时类的多态性的特性。下面是可以实现的操作：  </p>
<ul>
<li>父类当中的类方法、实例方法和属性可以被子类继承；</li>
<li>子类可以使用以父类为参数的方法和函数。</li>
</ul>
<p>下列操作目前是无法实现的：  </p>
<ul>
<li>多态类之间的强制转换（例如：子类转换为另一个子类，子类转换为父类，父类转换成子类，等等）；</li>
<li>同时对多个类进行检索；</li>
<li>包含多个类的容器（RLMArray 以及 RLMResults）。</li>
</ul>
<p>此外，如果您的代码实现允许的话，我们建议您使用下述模式，即使用类组合模式来构建子类，从而将其他类当中的逻辑给包含进去：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base Model</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSInteger</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 Animal 一并组合的模型</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Duck</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> Animal *animal;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Duck</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Frog</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> Animal *animal;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSDate</span> *dateProp;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Frog</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line">Duck *duck =  [[Duck alloc] initWithValue:@&#123;<span class="string">@"animal"</span> : @&#123;<span class="string">@"age"</span> : @(<span class="number">3</span>)&#125;, <span class="string">@"name"</span> : <span class="string">@"Gustav"</span> &#125;];</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><h4 id="1-多对一关系"><a href="#1-多对一关系" class="headerlink" title="1.多对一关系"></a>1.多对一关系</h4><p>要配置多对一或者一对一关系，在数据模型当中声明一个 RLMObject 子类类型的属性即可：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dog.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="comment">// ... 其余属性声明</span></span><br><span class="line"><span class="keyword">@property</span> Person *owner;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>操作关系属性的方法与其他属性类似：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person *jim = [[Person alloc] init];</span><br><span class="line">Dog    *rex = [[Dog alloc] init];</span><br><span class="line">rex.owner = jim;</span><br></pre></td></tr></table></figure>
<p>在使用 <code>RLMObject</code> 属性时，您可以使用正常的属性访问语法来访问嵌套属性。例如，<code>rex.owner.address.country</code> 将会遍历对象图，然后自动从 Realm 中检索出每个所需的对象。</p>
<h4 id="2-多对多关系"><a href="#2-多对多关系" class="headerlink" title="2.多对多关系"></a>2.多对多关系</h4><p>通过 <code>RLMArray</code> 属性，您可以为任意数量的对象或者所支持的原始类型之间构建关系。<code>RLMArray</code> 可以包含其它 <code>RLMObject</code> 类型，也可以包含简单类型的原始值，其接口与 <code>NSMutableArray</code> 非常类似。</p>
<p><code>RLMArray</code> 所包含的 <code>Realm</code> 对象可能会存储多个相同 Realm 对象的引用，即便对象带有主键也是如此。例如，您或许会创建一个空的 <code>RLMArray</code>，然后连续三次向其中插入同一个对象；每次分别使用 0、1、2 的元素索引来访问的时候，<code>RLMArray</code> 都会返回同一个对象。</p>
<p><code>RLMArray</code> 可以存储原始类型，从而代替一般的 <code>Realm</code> 对象。为了实现此功能， 请使用下列协议来约束 <code>RLMArray</code>：<code>RLMBool</code>、<code>RLMInt</code>、<code>RLMFloat</code>、<code>RLMDouble</code>、 <code>RLMString</code>、<code>RLMData</code> 或者 <code>RLMDate</code>。</p>
<p>默认情况下，包含原始类型的 <code>RLMArray</code> 可能也会包含空值（由 <code>NSNull</code> 表示）。 将数组标记为非可空（通过在数组所在的模型对象类型中重写 <code>+requiredProperties:</code>）， 同样也会导致数组当中的值变为非可空。</p>
<p>让我们给 <code>Person</code> 模型添加一个 <code>dogs</code> 属性，从而让其能够与多个 <code>Dog</code> 对象建立关系。首先，我们需要定义 <code>RLMArray&lt;Dog&gt;</code> 类型，也就是在 <code>Dog</code> 模型接口定义的底部使用这条宏：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dog.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="comment">// ... property declarations</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">RLM_ARRAY_TYPE(Dog) <span class="comment">// 定义 RLMArray&lt;Dog&gt; 类型</span></span><br></pre></td></tr></table></figure>
<p><code>RLM_ARRAY_TYPE</code> 宏创建了一个协议，从而允许您使用 <code>RLMArray&lt;Dog&gt;</code> 这种语法。如果这条宏没有放置在模型接口定义的底部，那么这个模型类就必须前置声明。</p>
<p>接下来，您就可以声明 <code>RLMArray&lt;Dog&gt;</code> 类型的属性了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="comment">// ...其他属性声明</span></span><br><span class="line"><span class="keyword">@property</span> RLMArray&lt;Dog *&gt;&lt;Dog&gt; *dogs;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>您可以照常对 RLMArray 属性进行访问和赋值：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Jim 是 Rex 和所有名为 "Fido" 狗狗的主人</span></span><br><span class="line">RLMResults&lt;Dog *&gt; *someDogs = [Dog objectsWhere:<span class="string">@"name contains 'Fido'"</span>];</span><br><span class="line">[jim.dogs addObjects:someDogs];</span><br><span class="line">[jim.dogs addObject:rex];</span><br></pre></td></tr></table></figure>
<p>注意，虽然可以给 <code>RLMArray</code> 属性赋值为 nil，但是这仅仅只会“清空”该数组，而不会将该数组给移除。这意味着您永远都可以向 <code>RLMArray</code> 属性中添加对象，即便其之前曾被置为 nil。</p>
<p><code>RLMArray</code> 属性会确保其内部的插入次序不会被打乱。</p>
<p><strong>注意，目前暂时不支持对包含原始类型的 RLMArray 进行查询。</strong></p>
<h4 id="3-双向关系"><a href="#3-双向关系" class="headerlink" title="3.双向关系"></a>3.双向关系</h4><p>关系是单向的。以 <code>Person</code> 和 <code>Dog</code> 这两个类为例。如果 <code>Person.dogs</code> 连接了一个 Dog 实例，那么您可以随着该连接从 <code>Person</code> 访问到对应的 <code>Dog</code>，但是是没有办法从 <code>Dog</code> 访问到对应的 <code>Person</code> 对象的。您可以设置一个一对一属性 <code>Dog.owner</code> 从而连接到 <code>Person</code>，但是这些连接实际上仍然是互相独立的。<strong>给 <code>Person.dogs</code> 添加一个 <code>Dog</code> 对象并不会将该对象的 <code>Dog.owner</code> 属性设置为对应的 <code>Person</code>。为了解决这个问题，Realm 提供了连接对象属性，从而表示这种双向关系</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSInteger</span> age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) RLMLinkingObjects *owners;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Dog</span></span></span><br><span class="line">+ (<span class="built_in">NSDictionary</span> *)linkingObjectsProperties &#123;</span><br><span class="line">    <span class="keyword">return</span> @&#123;</span><br><span class="line">        <span class="string">@"owners"</span>: [RLMPropertyDescriptor descriptorWithClass:Person.class propertyName:<span class="string">@"dogs"</span>],</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>借助连接对象属性，可以从特定属性获取连接到指定对象的所有对象。Dog 对象可以拥有一个名为 owners 属性，它包含所有 dogs 属性有该 Dog 对象的 Person 对象。将这个 owners 属性设置为 RLMLinkingObjects 类型，然后重写 +[RLMObject linkingObjectsProperties] 来表示 owners 与 Person 模型对象之间的关系。</p>
<hr>
<h2 id="数据库操作-增删改查"><a href="#数据库操作-增删改查" class="headerlink" title="数据库操作-增删改查"></a>数据库操作-增删改查</h2><h3 id="一-增"><a href="#一-增" class="headerlink" title="(一)增"></a>(一)增</h3><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>当定义完数据模型之后，就可以实例化 RLMObject 子类了， 然后还可以向 Realm 数据库中添加新的实例</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dog 数据模型</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSInteger</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Implementation</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Dog</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>创建新对象的方法有很多种：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1) 创建 Dog 对象，然后设置其属性</span></span><br><span class="line">Dog *myDog = [[Dog alloc] init];</span><br><span class="line">myDog.name = <span class="string">@"Rex"</span>;</span><br><span class="line">myDog.age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 从字典中创建 Dog 对象</span></span><br><span class="line">Dog *myOtherDog = [[Dog alloc] initWithValue:@&#123;<span class="string">@"name"</span> : <span class="string">@"Pluto"</span>, <span class="string">@"age"</span> : @<span class="number">3</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) 从数组中创建 Dog 对象</span></span><br><span class="line">Dog *myThirdDog = [[Dog alloc] initWithValue:@[<span class="string">@"Pluto"</span>, @<span class="number">3</span>]];</span><br></pre></td></tr></table></figure>
<p>对象创建之后，您就可以将其添加到 Realm 数据库了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取默认的 Realm 数据库</span></span><br><span class="line">RLMRealm *realm = [RLMRealm defaultRealm];</span><br><span class="line"><span class="comment">// （每个线程）只需执行一次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在事务中向 Realm 数据库中添加数据</span></span><br><span class="line">[realm beginWriteTransaction];</span><br><span class="line">[realm addObject:myDog];</span><br><span class="line">[realm commitWriteTransaction];</span><br></pre></td></tr></table></figure>

<h3 id="二-改"><a href="#二-改" class="headerlink" title="(二)改"></a>(二)改</h3><p>将对象添加到 Realm 数据库之后，您仍然可以继续使用它，并且对其进行的所有更改都会被存储（必须要在写入事务当中进行）。当写入事务提交之后，其他使用同一个 Realm 数据库的线程所做的更改都可以继续进行。</p>
<h4 id="1-直接更新"><a href="#1-直接更新" class="headerlink" title="1.直接更新"></a>1.直接更新</h4><p>您可以在写入事务中，通过设置对象的属性从而完成更新。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在事务中更新对象</span></span><br><span class="line">[realm beginWriteTransaction];</span><br><span class="line">author.name = <span class="string">@"Thomas Pynchon"</span>;</span><br><span class="line">[realm commitWriteTransaction];</span><br></pre></td></tr></table></figure>

<h4 id="2-键值编码"><a href="#2-键值编码" class="headerlink" title="2.键值编码"></a>2.键值编码</h4><p>RLMObject、RLMResult 和 RLMArray 均允许使用 键值编码(KVC)。 当您需要在运行时决定何种属性需要进行更新的时候， 这个方法就非常有用了。</p>
<p><strong>批量更新对象时，为集合实现 KVC 是一个很好的做法， 这样就不用承受遍历集合时为每个项目创建访问器 所带来的性能损耗。</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RLMResults&lt;Person *&gt; *persons = [Person allObjects];</span><br><span class="line">[[RLMRealm defaultRealm] transactionWithBlock:^&#123;</span><br><span class="line">    [[persons firstObject] setValue:@YES forKeyPath:<span class="string">@"isFirst"</span>];</span><br><span class="line">    <span class="comment">// 将每个 person 对象的 planet 属性设置为 "Earth"</span></span><br><span class="line">    [persons setValue:<span class="string">@"Earth"</span> forKeyPath:<span class="string">@"planet"</span>];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h4 id="3-通过主键更新"><a href="#3-通过主键更新" class="headerlink" title="3.通过主键更新"></a>3.通过主键更新</h4><p>如果数据模型类中包含了主键，那么 可以使用 -[RLMRealm addOrUpdateObject:]，从而让 Realm 基于主键来自动更新或者添加对象。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 book 对象，其主键与之前存储的 book 对象相同</span></span><br><span class="line">Book *cheeseBook = [[Book alloc] init];</span><br><span class="line">cheeseBook.title = <span class="string">@"Cheese recipes"</span>;</span><br><span class="line">cheeseBook.price = @<span class="number">9000</span>;</span><br><span class="line">cheeseBook.id = @<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新这个 id = 1 的 book</span></span><br><span class="line">[realm beginWriteTransaction];</span><br><span class="line">[realm addOrUpdateObject:cheeseBook];</span><br><span class="line">[realm commitWriteTransaction];</span><br></pre></td></tr></table></figure>
<p>如果这个主键值为 “1” 的 Book 对象已经存在于数据库当中 ，那么该对象只会进行更新。如果不存在的话， 那么一个全新的 Book 对象就会被创建出来，并被添加到数据库当中。</p>
<p>您可以通过传递一个子集，其中只包含打算更新的值， 从而对带有主键的对象进行部分更新：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设主键为 `1` 的 "Book" 对象已经存在</span></span><br><span class="line">[realm beginWriteTransaction];</span><br><span class="line">[Book createOrUpdateInRealm:realm withValue:@&#123;<span class="string">@"id"</span>: @<span class="number">1</span>, <span class="string">@"price"</span>: @<span class="number">9000.0</span>f&#125;];</span><br><span class="line"><span class="comment">// book 对象的 `title` 属性仍旧保持不变</span></span><br><span class="line">[realm commitWriteTransaction];</span><br></pre></td></tr></table></figure>
<p><strong>如果没有定义主键，那么最好不要对这类对象调用本节中所示的方法（也就是这些以 OrUpdate 结尾的方法）。</strong></p>
<h3 id="三-删"><a href="#三-删" class="headerlink" title="(三)删"></a>(三)删</h3><p>在写入事务中，将要删除的对象传递给 -[RLMRealm deleteObject:] 方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cheeseBook 存储在 Realm 数据库中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在事务中删除对象</span></span><br><span class="line">[realm beginWriteTransaction];</span><br><span class="line">[realm deleteObject:cheeseBook];</span><br><span class="line">[realm commitWriteTransaction];</span><br></pre></td></tr></table></figure>

<p>您同样也可以删除存储在 Realm 数据库当中的所有数据。请注意，Realm 文件会保留在磁盘上所占用的空间，从而为以后的对象预留足够的空间，从而实现快速存储。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 Realm 数据库中删除所有对象</span></span><br><span class="line">[realm beginWriteTransaction];</span><br><span class="line">[realm deleteAllObjects];</span><br><span class="line">[realm commitWriteTransaction];</span><br></pre></td></tr></table></figure>

<h3 id="四-查"><a href="#四-查" class="headerlink" title="(四)查"></a>(四)查</h3><p>查询将会返回一个 RLMResults 实例，其中包含了一组 RLMObject 对象。RLMResults 的接口与 NSArray 基本相同，并且可以使用索引下标来访问包含在 RLMResults 当中的对象。与 NSArray 所不同的是，RLMResults 中元素的类型是固定的，并且只能持有一个 RLMObject 子类类型。</p>
<p>从 Realm 数据库中检索对象的最基本方法是 +[RLMObject allObjects]，这个方法将会返回 RLMObject 子类类型在默认 Realm 数据库当中的查询到的所有数据，并以 RLMResults 实例的形式返回。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RLMResults&lt;Dog *&gt; *dogs = [Dog allObjects]; <span class="comment">// 从默认的 Realm 数据库中遍历所有 Dog 对象</span></span><br></pre></td></tr></table></figure>

<h4 id="1-条件查询"><a href="#1-条件查询" class="headerlink" title="1.条件查询"></a>1.条件查询</h4><p>如果您对 NSPredicate 有所了解的话，那么您就已经掌握了在 Realm 中进行查询的方法了。RLMObjects、RLMRealm、RLMArray 和 RLMResults 均提供了相关的方法，从而只需传递 NSPredicate 实例、断言字符串、或者断言格式化字符串来查询特定的 RLMObject 实例，这与对 NSArray 进行查询所类似。</p>
<p>例如，下面这个例子通过调用 [RLMObject objectsWhere:] 方法，从默认 Realm 数据库中遍历出所有棕黄色、名字以 “B” 开头的狗狗：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用断言字符串来查询</span></span><br><span class="line">RLMResults&lt;Dog *&gt; *tanDogs = [Dog objectsWhere:<span class="string">@"color = 'tan' AND name BEGINSWITH 'B'"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 NSPredicate 来查询</span></span><br><span class="line"><span class="built_in">NSPredicate</span> *pred = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"color = %@ AND name BEGINSWITH %@"</span>,</span><br><span class="line">                                                     <span class="string">@"tan"</span>, <span class="string">@"B"</span>];</span><br><span class="line">tanDogs = [Dog objectsWithPredicate:pred];</span><br></pre></td></tr></table></figure>

<p>Realm 支持大多数常见的断言：</p>
<ul>
<li>比较操作数可以是属性名，也可以是常量。但至少要有一个操作数是属性名；</li>
<li>比较操作符 ==、&lt;=、&lt;、&gt;=、&gt;、!= 和 BETWEEN 支持 int、long、long long、float、double 以及 NSDate 这几种属性类型，例如 age == 45；</li>
<li>比较是否相同：== 和 !=，例如，[Employee objectsWhere:@”company == %@”, company]；</li>
<li>比较操作符 == 和 != 支持布尔属性；</li>
<li>对于 NSString 和 NSData 属性而言，支持使用 ==、!=、BEGINSWITH、CONTAINS 和 ENDSWITH 操作符，例如 name CONTAINS ‘Ja’；</li>
<li>对于 NSString 属性而言，LIKE 操作符可以用来比较左端属性和右端表达式：? 和 * 可用作通配符，其中 ? 可以匹配任意一个字符，* 匹配 0 个及其以上的字符。例如：value LIKE ‘?bc*’ 可以匹配到诸如 “abcde” 和 “cbc” 之类的字符串；</li>
<li>字符串的比较忽略大小写，例如 name CONTAINS[c] ‘Ja’。请注意，只有 “A-Z” 和 “a-z” 之间的字符大小写会被忽略。[c] 修饰符可以与 [d] 修饰符结合使用；</li>
<li>字符串的比较忽略变音符号，例如 name BEGINSWITH[d] ‘e’ 能够匹配到 étoile。这个修饰符可以与 [c] 修饰符结合使用。（这个修饰符只能够用于 Realm 所支持的字符串子集：参见当前的限制一节来了解详细信息。）</li>
<li>Realm 支持以下组合操作符：“AND”、“OR” 和 “NOT”，例如 name BEGINSWITH ‘J’ AND age &gt;= 32；</li>
<li>包含操作符：IN，例如 name IN {‘Lisa’, ‘Spike’, ‘Hachi’}；</li>
<li>空值比较：==、!=，例如 [Company objectsWhere:@”ceo == nil”]。请注意，Realm 将 nil 视为一种特殊值，而不是某种缺失值；这与 SQL 不同，nil 等同于自身；</li>
<li>ANY 比较，例如 ANY student.age &lt; 21；</li>
<li>RLMArray 和 RLMResults 属性支持聚集表达式：@count、@min、@max、@sum 和 @avg，例如 [Company objectsWhere:@”employees.@count &gt; 5”] 可用以检索所有拥有 5 名以上雇员的公司。</li>
<li>支持子查询，不过存在以下限制：<ul>
<li>@count 是唯一一个能在 SUBQUERY 表达式当中使用的操作符；</li>
<li>SUBQUERY(…).@count 表达式只能与常量相比较；</li>
<li>目前仍不支持关联子查询。</li>
</ul>
</li>
</ul>
<h4 id="2-排序"><a href="#2-排序" class="headerlink" title="2.排序"></a>2.排序</h4><p>RLMResults 允许您指定一个排序标准，然后基于<strong><code>关键路径</code></strong>、<strong><code>属性</code></strong>或者多个<strong><code>排序描述符</code></strong>来进行排序。例如，下列代码让上述示例中返回的 Dog 对象按名字进行升序排序：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对颜色为棕黄色、名字以 "B" 开头的狗狗进行排序</span></span><br><span class="line">RLMResults&lt;Dog *&gt; *sortedDogs = [[Dog objectsWhere:<span class="string">@"color = 'tan' AND name BEGINSWITH 'B'"</span>]</span><br><span class="line">                                    sortedResultsUsingKeyPath:<span class="string">@"name"</span> ascending:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
<p>关键路径同样也可以是某个多对一关系属性。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RLMResults&lt;Person *&gt; *dogOwners = [Person allObjects];</span><br><span class="line">RLMResults&lt;Person *&gt; *ownersByDogAge = [dogOwners sortedResultsUsingKeyPath:<span class="string">@"dog.age"</span> ascending:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>

<p>请注意，<code>sortedResultsUsingKeyPath:</code> 和 <code>sortedResultsUsingProperty:</code> 不支持 将多个属性用作排序基准，此外也无法链式排序（只有最后一个 sortedResults… 调用会被使用）。 如果要对多个属性进行排序，请使用 <code>sortedResultsUsingDescriptors:</code>，然后向其中输入多个 RLMSortDescriptor` 对象。</p>
<h4 id="3-链式查询"><a href="#3-链式查询" class="headerlink" title="3.链式查询"></a>3.链式查询</h4><p>与传统数据库相比，Realm 查询引擎的一个独特特性就是：它能够用很小的事务开销来实现链式查询，而不是每条查询都要接二连三地分别去单独访问数据库服务器。</p>
<p>如果您需要获取一个棕黄色狗狗的结果集，然后在此基础上再获取名字以 ‘B’ 开头的棕黄色狗狗，那么您可以像这样将这两个查询连接起来：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RLMResults&lt;Dog *&gt; *tanDogs = [Dog objectsWhere:<span class="string">@"color = 'tan'"</span>];</span><br><span class="line">RLMResults&lt;Dog *&gt; *tanDogsWithBNames = [tanDogs objectsWhere:<span class="string">@"name BEGINSWITH 'B'"</span>];</span><br></pre></td></tr></table></figure>

<h4 id="4-结果的自更新"><a href="#4-结果的自更新" class="headerlink" title="4.结果的自更新"></a>4.结果的自更新</h4><p>RLMObject 实例是底层数据的动态体现，其会自动进行更新，这意味着您无需去重新检索结果。它们会直接映射出 Realm 数据库在当前线程中的状态，包括当前线程上的写入事务。唯一的例外是，在使用 for…in 枚举时，它会将刚开始遍历时满足匹配条件的所有对象给遍历完，即使在遍历过程中有对象被过滤器修改或者删除。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RLMResults&lt;Dog *&gt; *puppies = [Dog objectsInRealm:realm where:<span class="string">@"age &lt; 2"</span>];</span><br><span class="line">puppies.count; <span class="comment">// =&gt; 0</span></span><br><span class="line"></span><br><span class="line">[realm transactionWithBlock:^&#123;</span><br><span class="line">    [Dog createInRealm:realm withValue:@&#123;<span class="string">@"name"</span>: <span class="string">@"Fido"</span>, <span class="string">@"age"</span>: @<span class="number">1</span>&#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">puppies.count; <span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure>

<h4 id="5-限制查询结果"><a href="#5-限制查询结果" class="headerlink" title="5.限制查询结果"></a>5.限制查询结果</h4><p>大多数其他数据库技术都提供了从检索中对结果进行“分页”的能力（例如 SQLite 中的 “LIMIT” 关键字）。这通常是很有必要的，可以避免一次性从硬盘中读取太多的数据，或者将太多查询结果加载到内存当中。</p>
<p><strong><code>由于 Realm 中的检索是惰性的，因此这行这种分页行为是没有必要的</code></strong>。因为 Realm 只会在检索到的结果被明确访问时，才会从其中加载对象。</p>
<p>如果由于 UI 相关或者其他代码实现相关的原因导致您需要从检索中获取一个特定的对象子集，这和获取 RLMResults 对象一样简单，只需要读出您所需要的对象即可。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环读取出前 5 个 Dog 对象</span></span><br><span class="line"><span class="comment">// 从而限制从磁盘中读取的对象数量</span></span><br><span class="line">RLMResults&lt;Dog *&gt; *dogs = [Dog allObjects];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    Dog *dog = dogs[i];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h2><h3 id="一-本地迁移"><a href="#一-本地迁移" class="headerlink" title="(一)本地迁移"></a>(一)本地迁移</h3><p>通过设置 RLMRealmConfiguration.schemaVersion 以及 RLMRealmConfiguration.migrationBlock 可以定义本地迁移。迁移模块将提供所有的逻辑操作，以便将数据模型从之前的架构转换为新的架构。每当用配置对象创建完 RLMRealm 之后，如果需要进行迁移的话，那么迁移模块就会将 RLMRealm 更新至指定的架构版本。<br>假设我们需要将上面所声明的 Person 模型进行迁移。下述代码是最精简的数据模块：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此段代码位于 [AppDelegate didFinishLaunchingWithOptions:]</span></span><br><span class="line"></span><br><span class="line">RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line"><span class="comment">// 设置新的架构版本。必须大于之前所使用的版本</span></span><br><span class="line"><span class="comment">// （如果之前从未设置过架构版本，那么当前的架构版本为 0）</span></span><br><span class="line">config.schemaVersion = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置模块，如果 Realm 的架构版本低于上面所定义的版本，</span></span><br><span class="line"><span class="comment">// 那么这段代码就会自动调用</span></span><br><span class="line">config.migrationBlock = ^(RLMMigration *migration, uint64_t oldSchemaVersion) &#123;</span><br><span class="line">    <span class="comment">// 我们目前还未执行过迁移，因此 oldSchemaVersion == 0</span></span><br><span class="line">    <span class="keyword">if</span> (oldSchemaVersion &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有什么要做的！</span></span><br><span class="line">        <span class="comment">// Realm 会自行检测新增和被移除的属性</span></span><br><span class="line">        <span class="comment">// 然后会自动更新磁盘上的架构</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知 Realm 为默认的 Realm 数据库使用这个新的配置对象</span></span><br><span class="line">[RLMRealmConfiguration setDefaultConfiguration:config];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在我们已经通知了 Realm 如何处理架构变化，</span></span><br><span class="line"><span class="comment">// 打开文件将会自动执行迁移</span></span><br><span class="line">[RLMRealm defaultRealm];</span><br></pre></td></tr></table></figure>

<h4 id="1-值的更新"><a href="#1-值的更新" class="headerlink" title="1.值的更新"></a>1.值的更新</h4><p>虽然这个迁移操作是最精简的了，但是我们需要让这个闭包能够自行计算新的属性（这里指的是 fullName），这样才有意义。 在迁移模块中，我们能够调用 [RLMMigration enumerateObjects:block:] 来枚举特定类型的每个 RLMObject 对象，然后执行必要的迁移逻辑。注意，对枚举中每个已存在的 RLMObject 实例来说，应该是通过访问 oldObject 对象进行访问，而更新之后的实例应该通过 newObject 进行访问：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此段代码位于 [AppDelegate didFinishLaunchingWithOptions:]</span></span><br><span class="line"></span><br><span class="line">RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line">config.schemaVersion = <span class="number">1</span>;</span><br><span class="line">config.migrationBlock = ^(RLMMigration *migration, uint64_t oldSchemaVersion) &#123;</span><br><span class="line">    <span class="comment">// 我们目前还未执行过迁移，因此 oldSchemaVersion == 0</span></span><br><span class="line">    <span class="keyword">if</span> (oldSchemaVersion &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// enumerateObjects:block: 方法将会遍历</span></span><br><span class="line">        <span class="comment">// 所有存储在 Realm 文件当中的 `Person` 对象</span></span><br><span class="line">        [migration enumerateObjects:Person.className</span><br><span class="line">                              block:^(RLMObject *oldObject, RLMObject *newObject) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将两个 name 合并到 fullName 当中</span></span><br><span class="line">        newObject[<span class="string">@"fullName"</span>] = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ %@"</span>,</span><br><span class="line">                                      oldObject[<span class="string">@"firstName"</span>],</span><br><span class="line">                                      oldObject[<span class="string">@"lastName"</span>]];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">[RLMRealmConfiguration setDefaultConfiguration:config];</span><br></pre></td></tr></table></figure>
<p>一旦迁移成功结束，Realm 文件和其中的所有对象都可被您的应用正常访问。</p>
<h4 id="2-属性重命名"><a href="#2-属性重命名" class="headerlink" title="2.属性重命名"></a>2.属性重命名</h4><p>在迁移过程中对类中某个属性进行重命名操作， 比起拷贝值和保留关系来说要更为高效。</p>
<p>要在迁移过程中对某个属性就进行重命名的话，请确保您的新模型当中的这个属性是一个全新的名字， 它的名字不能和原有模型当中的名字重合。</p>
<p>如果新的属性拥有不同的可空性或者索引设置的话， 这些配置会在重命名操作期间生效。</p>
<p>下面是一个例子，展示了您该如何将 Person 的 yearsSinceBirth 属性重命名为 age 属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此段代码位于 [AppDelegate didFinishLaunchingWithOptions:]</span></span><br><span class="line"></span><br><span class="line">RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line">config.schemaVersion = <span class="number">1</span>;</span><br><span class="line">config.migrationBlock = ^(RLMMigration *migration, uint64_t oldSchemaVersion) &#123;</span><br><span class="line">    <span class="comment">// 我们目前还未执行过迁移，因此 oldSchemaVersion == 0</span></span><br><span class="line">    <span class="keyword">if</span> (oldSchemaVersion &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 重命名操作必须要在 `enumerateObjects:` 调用之外进行</span></span><br><span class="line">        [migration renamePropertyForClass:Person.className oldName:<span class="string">@"yearsSinceBirth"</span> newName:<span class="string">@"age"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">[RLMRealmConfiguration setDefaultConfiguration:config];</span><br></pre></td></tr></table></figure>

<h4 id="3-线性迁移"><a href="#3-线性迁移" class="headerlink" title="3.线性迁移"></a>3.线性迁移</h4><p>假如说，我们的应用有两个用户： JP 和 Tim。JP 经常更新应用，但 Tim 却经常跳过某些版本。所以 JP 可能下载过这个应用的每一个版本，并且一步一步地跟着更新构架：第一次下载更新后，数据库架构从 v0 更新到 v1；第二次架构从 v1 更新到 v2…以此类推，井然有序。相反，Tim 很有可能直接从 v0 版本直接跳到了 v2 版本。 因此，您应该使用非嵌套的 if (oldSchemaVersion &lt; X) 结构来构造您的数据库迁移模块，以确保无论用户在使用哪个版本的架构，都能完成必需的更新。</p>
<p>当您的用户不按套路出牌，跳过有些更新版本的时候，另一种情况也会发生。假如您在 v2 里删掉了一个 “email” 属性，然后在 v3 里又把它重新引进了。假如有个用户从 v1 直接跳到 v3，那 Realm 不会自动检测到 v2 的这个删除操作，因为存储的数据架构和代码中的架构吻合。这会导致 Tim 的 Person 对象有一个 v3 的 email 属性，但里面的内容却是 v1 的。这个看起来没什么大问题，但是假如两者的内部存储类型不同（比如说： 从 ISO email 标准格式变成了自定义格式），那麻烦就大了。为了避免这种不必要的麻烦，我们推荐您在 if (oldSchemaVersion &lt; 3) 语句中，清空所有的 email 属性。</p>
<h3 id="（二）迁移同步-比较复杂不常用"><a href="#（二）迁移同步-比较复杂不常用" class="headerlink" title="（二）迁移同步(比较复杂不常用)"></a>（二）迁移同步(比较复杂不常用)</h3><p>当 Realm 数据库与 Realm 对象服务器同步时，迁移过程会有所不同——在很多情况下，其实会更加简单。下面是您所需要知晓的全部内容：</p>
<ul>
<li>无需设置架构版本（尽管您可以这样做）；</li>
<li>新增内容的更改会自动进行，例如添加类或者向类中添加字段；</li>
<li>从架构中将某个字段移除并不会从数据库中删除该字段，而是指示 Realm 忽略该字段。新的对象创建的时候仍然会使用这些属性，但是它们都将会被设置为 null。不可空的字段将被恰当地设置为零/空值：数字字段将被置为 0，字符串属性将被置为空字符串，等等。</li>
<li>您不能添加迁移模块。<br>假设您的应用中有一个 Dog 类：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
现在您需要添加 Person 类，并建立一个到 Dog 的 owner 关系。除了添加类和相关属性之外，在同步之前您无需执行任何操作：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> Person   *owner;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">RLM_ARRAY_TYPE(Dog)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSDate</span>   *birthdate;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">RLM_ARRAY_TYPE(Person)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Objecitve-C 引用类型的非可空属性</span></span><br><span class="line"><span class="comment">// 必须以这种形式进行声明：</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)requiredProperties &#123;</span><br><span class="line">    <span class="keyword">return</span> @[<span class="string">@"name"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURL</span> *syncServerURL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://localhost:9080/Dogs"</span>];</span><br><span class="line">RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line">config.syncConfiguration = [[RLMSyncConfiguration alloc] initWithUser:user realmURL:syncServerURL];</span><br><span class="line"></span><br><span class="line">RLMRealm *realm = [RLMRealm realmWithConfiguration:config error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
由于可同步 Realm 数据库不支持迁移模块，因此迁移当中的破坏性更改——例如主键更改、既有字段的字段类型更改（同时保留相同的名称），以及将属性从可空更改为非可空，诸如此类的操作，都需要用另外的方式来进行处理。创建一个新的具备新架构的可同步 Realm 数据库，然后将数据从旧的 Realm 数据库复制到新的 Realm 数据库：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> Person *owner;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">RLM_ARRAY_TYPE(Dog)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">RLM_ARRAY_TYPE(Person)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)requiredProperties &#123;</span><br><span class="line">    <span class="keyword">return</span> @[<span class="string">@"name"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PersonV2</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">RLM_ARRAY_TYPE(PersonV2)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PersonV2</span></span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)requiredProperties &#123;</span><br><span class="line">    <span class="keyword">return</span> @[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSURL</span> *syncServerURL = [<span class="built_in">NSURL</span> URLWithString: <span class="string">@"realm://localhost:9080/Dogs"</span>];</span><br><span class="line">RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line">config.syncConfiguration = [[RLMSyncConfiguration alloc] initWithUser:user realmURL:syncServerURL];</span><br><span class="line"><span class="comment">// 限制初始对象类型</span></span><br><span class="line">config.objectClasses = @[Dog.class, Person.class];</span><br><span class="line"></span><br><span class="line">RLMRealm *initialRealm = [RLMRealm realmWithConfiguration:config error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">syncServerURL = [<span class="built_in">NSURL</span> URLWithString: <span class="string">@"realm://localhost:9080/DogsV2"</span>];</span><br><span class="line">config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line">config.syncConfiguration = [[RLMSyncConfiguration alloc] initWithUser:user realmURL:syncServerURL];</span><br><span class="line"><span class="comment">// 限制新对象类型</span></span><br><span class="line">config.objectClasses = @[Dog.class, PersonV2.class];</span><br><span class="line"></span><br><span class="line">RLMRealm *newRealm = [RLMRealm realmWithConfiguration:config error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
此外，对于可同步 Realm 数据库而言，还可以在客户端上编写一个通知处理器，或者使用 Node.js SDK 在服务器上编写一段 JavaScript 函数（如果您所使用的对象服务器版本支持的话），来执行自定义迁移。但是，如果迁移过程中出现了破坏性更改，那么 Realm 将停止与 Realm 对象服务器进行同步，并产生 Bad changeset received 错误。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/05/12/FMDB%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90/" rel="next" title="FMDB使用分析">
                <i class="fa fa-chevron-left"></i> FMDB使用分析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/05/12/%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86/" rel="prev" title="图像绘制原理">
                图像绘制原理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Lanht</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Realm"><span class="nav-number">1.</span> <span class="nav-text">Realm</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Realm数据库"><span class="nav-number">1.1.</span> <span class="nav-text">Realm数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#打开数据库"><span class="nav-number">1.1.1.</span> <span class="nav-text">打开数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-配置-Realm-数据库"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">1.配置 Realm 数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-默认Realm数据库"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">2.默认Realm数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-内存中-Realm-数据库"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">3.内存中 Realm 数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-错误处理"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">4.错误处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-预植-Realm-数据库"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">5.预植 Realm 数据库</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用类"><span class="nav-number">1.2.</span> <span class="nav-text">常用类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据模型"><span class="nav-number">1.3.</span> <span class="nav-text">数据模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-支持的数据类型"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.支持的数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-必要属性"><span class="nav-number">1.3.2.</span> <span class="nav-text">2.必要属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-主键"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.主键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-索引属性"><span class="nav-number">1.3.4.</span> <span class="nav-text">4.索引属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-被忽略属性"><span class="nav-number">1.3.5.</span> <span class="nav-text">5.被忽略属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-默认属性值"><span class="nav-number">1.3.6.</span> <span class="nav-text">6.默认属性值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-属性特性"><span class="nav-number">1.3.7.</span> <span class="nav-text">7.属性特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-属性备忘单"><span class="nav-number">1.3.8.</span> <span class="nav-text">8.属性备忘单</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模型继承"><span class="nav-number">1.4.</span> <span class="nav-text">模型继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关系"><span class="nav-number">1.5.</span> <span class="nav-text">关系</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-多对一关系"><span class="nav-number">1.5.0.1.</span> <span class="nav-text">1.多对一关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-多对多关系"><span class="nav-number">1.5.0.2.</span> <span class="nav-text">2.多对多关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-双向关系"><span class="nav-number">1.5.0.3.</span> <span class="nav-text">3.双向关系</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库操作-增删改查"><span class="nav-number">1.6.</span> <span class="nav-text">数据库操作-增删改查</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一-增"><span class="nav-number">1.6.1.</span> <span class="nav-text">(一)增</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建对象"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">创建对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二-改"><span class="nav-number">1.6.2.</span> <span class="nav-text">(二)改</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-直接更新"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">1.直接更新</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-键值编码"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">2.键值编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-通过主键更新"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">3.通过主键更新</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三-删"><span class="nav-number">1.6.3.</span> <span class="nav-text">(三)删</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四-查"><span class="nav-number">1.6.4.</span> <span class="nav-text">(四)查</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-条件查询"><span class="nav-number">1.6.4.1.</span> <span class="nav-text">1.条件查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-排序"><span class="nav-number">1.6.4.2.</span> <span class="nav-text">2.排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-链式查询"><span class="nav-number">1.6.4.3.</span> <span class="nav-text">3.链式查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-结果的自更新"><span class="nav-number">1.6.4.4.</span> <span class="nav-text">4.结果的自更新</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-限制查询结果"><span class="nav-number">1.6.4.5.</span> <span class="nav-text">5.限制查询结果</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据迁移"><span class="nav-number">1.7.</span> <span class="nav-text">数据迁移</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一-本地迁移"><span class="nav-number">1.7.1.</span> <span class="nav-text">(一)本地迁移</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-值的更新"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">1.值的更新</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-属性重命名"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">2.属性重命名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-线性迁移"><span class="nav-number">1.7.1.3.</span> <span class="nav-text">3.线性迁移</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#（二）迁移同步-比较复杂不常用"><span class="nav-number">1.7.2.</span> <span class="nav-text">（二）迁移同步(比较复杂不常用)</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lanht</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
